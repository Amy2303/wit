// Copyright (c) 2013, Webit Team. All Rights Reserved.

package webit.script.core;

import java.util.HashMap;
import java.util.Map;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.method.*;
import webit.script.core.ast.statments.*;
import webit.script.core.java_cup.runtime.Stack;
import webit.script.core.java_cup.runtime.Symbol;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.StatmentUtil;


parser code {:
    public Parser() {
        super(START_STATE, PRODUCTION_TABLE, ACTION_TABLE, REDUCE_TABLE);
    }
    
    private Stack<Symbol> getStack() {
        return this._stack;
    }

    private final NativeImportManager nativeImportMgr = new NativeImportManager();
    private final VariantManager varmgr = new VariantManager();
    private final Map<String, Integer> labelsIndexMap = new HashMap<String, Integer>();
    {
        labelsIndexMap.put(null, 0);
    }
    private int currentLabelIndex = 0;
    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }
    
    private void registClass(ClassNameBand classNameBand, int line, int column) {
        try {
            nativeImportMgr.registClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }
    
    private Class<?> toClass(ClassNameBand classNameBand, int line, int column) {
        try {
            return nativeImportMgr.toClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private void pushVarMgrForFunction(){
        varmgr.push();
        varmgr.pushVarWall();
    }

    private int assignVariant(String ident, int line, int column) {
        try {
            return varmgr.assignVariant(ident);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private int locateVarAtUpstairForce(String name, int upstair, int line, int column) {
        try {
            return varmgr.locateAtUpstair(name, upstair, true);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private VarAddress locateVar(String name, int line, int column) {
        try {
            return varmgr.locate(name, this.locateVarForce);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private ForInStatmentPart createForInStatmentPart(String item, Expression items, int line, int column){
        try {
            int itemIndex = varmgr.assignVariantForNextBlock(item);
            int iterIndex = varmgr.assignVariantForNextBlock("for.iter");

            return new ForInStatmentPart(itemIndex, iterIndex, items, line, column);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private ForMapStatmentPart createForMapStatmentPart(String key, String value, Expression map, int line, int column){
        try {
            int keyIndex = varmgr.assignVariantForNextBlock(key);
            int valueIndex = varmgr.assignVariantForNextBlock(value);
            int iterIndex = varmgr.assignVariantForNextBlock("for.iter");

            return new ForMapStatmentPart(keyIndex, valueIndex, iterIndex, map, line, column);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private BlockStatmentPart createBlockStatmentPart(int line, int column) {
        varmgr.push();
        return new BlockStatmentPart(line, column);
    }

    private IBlockStatment createBlockStatment(BlockStatmentPart part) {
        return part.setVarMap(varmgr.pop()).pop();
    }

    private ResetableValueExpression createContextValue(String name, int line, int column) {
        VarAddress addr;
        return (addr = locateVar(name, line, column)).upstairs == 0
                ? new CurrentContextValue(addr.index, name, line, column)
                : new ContextValue(addr.upstairs, addr.index, name, line, column);
    }

    private ResetableValueExpression createContextValue(int upstair, String name, int line, int column) {
        int index = locateVarAtUpstairForce(name, upstair, line, column);
        return upstair == 0
                ? new CurrentContextValue(index, name, line, column)
                : new ContextValue(upstair, index, name, true, line, column);
    }

    private ResetableValueExpression castToResetableValueExpression(Expression rexpr, int line, int column) {
        if(rexpr instanceof ResetableValueExpression){
            return (ResetableValueExpression) rexpr;
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", line, column);
        }
    }

    private Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){
        ResetableValueExpression leftExpr = castToResetableValueExpression(lexpr, line, column);
        SelfOperator oper;
        switch (sym) {

            // (+ - * / %)=
            case Operators.PLUSEQ:
                oper = new SelfPlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MINUSEQ:
                oper = new SelfMinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MULTEQ:
                oper = new SelfMultOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.DIVEQ:
                oper = new SelfDivOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MODEQ:
                oper = new SelfModOperator(leftExpr, rightExpr, line, column);
                break;

            // (<< >> >>>)=
            case Operators.LSHIFTEQ:
                oper = new SelfLShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.RSHIFTEQ:
                oper = new SelfRShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.URSHIFTEQ:
                oper = new SelfURShiftOperator(leftExpr, rightExpr, line, column);
                break;

            // (& ^ |)=
            case Operators.ANDEQ:
                oper = new SelfBitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.XOREQ:
                oper = new SelfBitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.OREQ:
                oper = new SelfBitOrOperator(leftExpr, rightExpr, line, column);
                break;

            default:
                throw new ParseException("Unsupported Operator", line, column);
        }

        return StatmentUtil.optimize(oper);
    }

    private Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new AndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new DivOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new EqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new GreaterOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new LessOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new MinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new ModOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new MultOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new OrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new PlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStepOperator(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatmentUtil.optimize(oper);
    }

:};


/* Terminals */
terminal Integer    VAR,
                    IF, ELSE,
                    FOR, /* IN, */
                    THIS, SUPER,
                    SWITCH, CASE, DEFAULT,
                    DO, WHILE,
                    THROW, TRY, CATCH, FINALLY,
                    NEW,
                    INSTANCEOF,
                    FUNCTION,
                    ECHO,
                    STATIC, NATIVE,
                    IMPORT, INCLUDE, NATIVE_IMPORT,
                    BREAK, CONTINUE, RETURN
                    ;


terminal Integer    PLUSPLUS, MINUSMINUS,  // ++ ==
                    PLUS, MINUS, MULT, DIV, MOD,  // + - * /
                    LSHIFT, RSHIFT, URSHIFT,  // << >> >>>
                    LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ,  // < > <= >= == !=
                    AND, XOR, OR, COMP,  // & ^ | ~
                    ANDAND, OROR, NOT,  // && || !
                    QUESTION, QUESTION_COLON,// ?  ?:
                    SELFEQ,  // (+ - * / %)= (<< >> >>>)= (& ^ |)=
                    UMINUS,
                    DOT,  // .
                    COLON,  // :
                    COMMA,  // ,
                    SEMICOLON,  // ;
                    LBRACE, RBRACE,  // { }
                    LPAREN, RPAREN,  // ( )
                    LBRACK, RBRACK,  // [ ]
                    EQGT,  // =>
                    AT,  // @
                    DOTDOT,  // ..
                    EQ   // =
                    ;


terminal String     IDENTIFIER; // Ident


terminal Number     INTEGER_LITERAL;
terminal Number     FLOATING_POINT_LITERAL;
terminal Boolean    BOOLEAN_LITERAL;
terminal Character  CHARACTER_LITERAL;
terminal String     STRING_LITERAL;

terminal            NULL_LITERAL;


terminal Integer    PLACE_HOLDER_END; // "}"
terminal char[]     TEXT_STATMENT;


/* non terminal */

non terminal directValue;
non terminal ClassNameBand classPureName;
non terminal ClassNameBand className;

/* TemplateAST */
non terminal TemplateAST templateAST;
non terminal TemplateASTPart templateASTPart;


/* function */
non terminal FunctionPart funcPart,funcPart0,funcPart1;

non terminal Expression funcExecuteExpr;

non terminal FunctionExecuteExpressionPart funcExecuteExprPart0, funcExecuteExprPart1;


non terminal NativeMethodDeclareExpressionPart nativeMethodExprPart, nativeMethodExprPart1;

non terminal NativeConstructorDeclareExpressionPart nativeConstructorExprPart1, nativeConstructorExprPart;


/* Statment */

non terminal Statment statment;

non terminal Statment varStatment;
non terminal varStatmentPart;

non terminal Statment includeStat;  // include
non terminal Statment importStat;  // import
non terminal ImportStatmentPart  importStatPart1, importStatPart2;


non terminal BlockStatmentPart blockStatPart;

non terminal IBlockStatment blockStat;
non terminal Statment forInStat;
non terminal Statment ifStat;
non terminal Statment forMapStat;
non terminal Statment whileStat;
non terminal Statment switchStat;


non terminal BlockStatmentPart caseBlockStatPart;
non terminal IBlockStatment caseBlockStat;
non terminal SwitchStatmentPart switchStatPart, switchStatPart0;
non terminal ForInStatmentPart forInStatPart, forInStatPart0, forInStatPart1;
non terminal ForMapStatmentPart forMapStatPart, forMapStatPart0, forMapStatPart1;
non terminal WhileStatmentPart whileStatPart, whileStatPart0;
non terminal IfStatmentPart ifStatPart;


/* special Operators */


non terminal Expression expression;
non terminal Expression expression_stat;


non terminal ArrayValuePart arrayValuePart;

non terminal MapValuePart mapValuePart;
non terminal MapValue mapValue;

/* Operators */

non terminal String contextValueIdent;
non terminal Integer superCount;
non terminal ResetableValueExpression contextValueExpr; // 




/* precedence */

precedence left     SEMICOLON; // ;

precedence right    SELFEQ,  // (+ - * / %)=  (<< >> >>>)=  (& ^ |)=
                    EQ // = 
                    ;

precedence left     DOTDOT;  // ..
precedence right    QUESTION, QUESTION_COLON; // [? : ] ?:
precedence left     OROR; // ||
precedence left     ANDAND; // &&
precedence left     XOR; // ^
precedence left     OR; // |
precedence left     AND; // &
precedence left     EQEQ, NOTEQ; // == !=
precedence left     LT, LTEQ, GT, GTEQ; // < <= > >=  //Unsupport: instanceOf
precedence left     LSHIFT, RSHIFT, URSHIFT; // << >> >>>
precedence left     PLUS, MINUS; // + -
precedence left     MULT, DIV, MOD; // * / %
precedence right    PLUSPLUS, MINUSMINUS, UMINUS, NOT, COMP; // ++ -- - ! ~
precedence left     EQGT;  // =>
precedence left     DOT, LBRACK, LPAREN, LBRACE, AT; // . [ ( { @



/* templateAST */

templateAST            ::= templateASTPart:part
                        {: return (%part%).setVarMap(varmgr.pop()).pop(); :}
                        ;


templateASTPart        ::= templateASTPart:part statment:stat
                        {: return (%part%).append(%stat%); :}
                        |
                        {: return new TemplateASTPart(); :}
                        ;


classPureName       ::= IDENTIFIER:ident
                        {: return new ClassNameBand(%ident%); :}
                        |classPureName:part DOT IDENTIFIER:ident
                        {: return (%part%).append(%ident%); :}
                        ;

className           ::= classPureName:part
                        {: return %part%; :}
                        |className:part LBRACK RBRACK
                        {: return (%part%).plusArrayDepth(); :}
                        ;


/* special Statments  */

statment            ::= expression_stat:expr SEMICOLON
                        {: return %expr%; :}
                        |SEMICOLON
                        {: return NoneStatment.getInstance(); :}
                        |expression:expr PLACE_HOLDER_END
                        {: return placeHolderStatmentFactory.creatPlaceHolderStatment(%expr%); :}
                        |varStatment:stat
                        {: return %stat%; :}
                        |blockStat:stat
                        {: return %stat%; :}
                        |ifStat:stat
                        {: return %stat%; :}
                        |forInStat:stat
                        {: return %stat%; :}
                        |forMapStat:stat
                        {: return %stat%; :}
                        |whileStat:stat
                        {: return %stat%; :}
                        |switchStat:stat
                        {: return %stat%; :}
                        |importStat:stat
                        {: return %stat%; :}
                        |includeStat:stat
                        {: return %stat%; :}

                        //redirectOutStat
                        |blockStat:stat EQGT:sym expression:expr SEMICOLON
                        {: return new RedirectOutStatment(%stat%, castToResetableValueExpression(%expr%, %sym.line%, %sym.column%), %sym.line%, %sym.column%); :}

                        //textStat
                        |TEXT_STATMENT:sym
                        {: return textStatmentFactory.getTextStatment(template, %sym%, %sym.line%, %sym.column%); :}

                        //varStatment
                        |varStatmentPart SEMICOLON
                        {: return NoneStatment.getInstance(); :}

                        //echoStat
                        |ECHO:sym expression:expr SEMICOLON
                        {: return new EchoStatment(%expr%, %sym.line%, %sym.column%); :}

                        //@import
                        |NATIVE_IMPORT:sym classPureName:nameBand SEMICOLON
                        {: registClass(%nameBand%, %sym.line%, %sym.column%); return NoneStatment.getInstance(); :}
                        //|NATIVE_IMPORT:sym classPureName:nameBand DOT MULT SEMICOLON
                        //{: registPackage(%nameBand%, %sym.line%, %sym.column%); return NoneStatment.getInstance(); :}
                        
                        //BREAK
                        |BREAK:sym SEMICOLON
                        {: return new BreakStatment(0, %sym.line%, %sym.column%); :}
                        |BREAK:sym IDENTIFIER:label SEMICOLON
                        {: return new BreakStatment(getLabelIndex(%label%), %sym.line%, %sym.column%); :}
                        
                        //CONTINUE
                        |CONTINUE:sym SEMICOLON
                        {: return new ContinueStatment(0, %sym.line%, %sym.column%); :}
                        |CONTINUE:sym IDENTIFIER:label SEMICOLON
                        {: return new ContinueStatment(getLabelIndex(%label%), %sym.line%, %sym.column%); :}
                        
                        //RETURN
                        |RETURN:sym SEMICOLON
                        {: return new ReturnStatment(null, %sym.line%, %sym.column%); :}
                        |RETURN:sym expression:expr SEMICOLON
                        {: return new ReturnStatment(%expr%, %sym.line%, %sym.column%); :}
                        ;



varStatmentPart     ::= VAR IDENTIFIER:ident
                        {: assignVariant(%ident%,%ident.line%,%ident.column%); return null;:}
                        |varStatmentPart COMMA IDENTIFIER:ident
                        {: assignVariant(%ident%,%ident.line%,%ident.column%); return null;:}
                        ;



importStatPart1     ::= IMPORT:sym expression:expr
                        {: return new ImportStatmentPart(%expr%, %sym.line%, %sym.column%); :}
                        |IMPORT:sym expression:expr mapValue:paramsExpr
                        {: return new ImportStatmentPart(%expr%, %sym.line%, %sym.column%).setParamsExpr(%paramsExpr%); :}
                        |IMPORT:sym expression:expr LBRACE expression:paramsExpr RBRACE
                        {: return new ImportStatmentPart(%expr%, %sym.line%, %sym.column%).setParamsExpr(%paramsExpr%); :}
                        ;



importStatPart2     ::= importStatPart1:part IDENTIFIER:ident
                        {: return (%part%).append(%ident%, createContextValue(%ident%, %ident.line%, %ident.column%)); :}
                        |importStatPart1:part contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: return (%part%).append(%ident%, %valueExpr%); :}
                        |importStatPart2:part COMMA IDENTIFIER:ident
                        {: return (%part%).append(%ident%, createContextValue(%ident%, %ident.line%, %ident.column%)); :}
                        |importStatPart2:part COMMA contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: return (%part%).append(%ident%, %valueExpr%); :}
                        ;


importStat          ::= importStatPart1:part SEMICOLON
                        {: return (%part%).pop(); :}
                        |importStatPart2:part SEMICOLON
                        {: return (%part%).pop(); :}
                        ;


includeStat         ::= INCLUDE:sym expression:expr SEMICOLON
                        {: return new IncludeStatment(%expr%, null, %sym.line%, %sym.column%); :}
                        |INCLUDE:sym expression:expr mapValue:paramsExpr SEMICOLON
                        {: return new IncludeStatment(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        |INCLUDE:sym expression:expr LBRACE expression:paramsExpr RBRACE SEMICOLON
                        {: return new IncludeStatment(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        ;


blockStatPart       ::= LBRACE:sym // statment:stat
                        {: return createBlockStatmentPart(%sym.line%, %sym.column%); :}
                        |blockStatPart:part statment:stat
                        {: return (%part%).append(%stat%); :}
                        ;


blockStat           ::= blockStatPart:part RBRACE
                        {: return createBlockStatment(%part%); :}
                        ;


ifStatPart          ::= IF:sym LPAREN expression:expr RPAREN blockStat:body
                        {: return new IfStatmentPart(%expr%, %sym.line%, %sym.column%).setThenStatment(%body%); :}
                        ;


ifStat              ::= ifStatPart:part
                        {: return (%part%).pop(); :}
                        |ifStatPart:part ELSE blockStat:elseBody
                        {: return (%part%).setElseStatment(%elseBody%).pop(); :}
                        |ifStatPart:part ELSE ifStat:elseBody
                        {: return (%part%).setElseStatment(%elseBody%).pop(); :}
                        ;


forInStatPart0        ::= FOR:sym LPAREN IDENTIFIER:item COLON expression:items RPAREN
                        {: return createForInStatmentPart(%item%, %items%, %sym.line%, %sym.column%); :}
                        ;


forInStatPart1     ::= forInStatPart0:part
                        {: return %part%; :}
                        |IDENTIFIER:label COLON forInStatPart0:part
                        {: return (%part%).setLabel(getLabelIndex(%label%)); :}
                        ;


forInStatPart         ::= forInStatPart1:part blockStat:body
                        {: return (%part%).setBodyStatment(%body%); :}
                        ;


forInStat             ::= forInStatPart:part
                        {: return (%part%).pop(); :}
                        |forInStatPart:part ELSE blockStat:elseBody
                        {: return (%part%).setElseStatment(%elseBody%).pop(); :}
                        ;


forMapStatPart0     ::= FOR:sym LPAREN IDENTIFIER:key COMMA IDENTIFIER:value COLON expression:map RPAREN
                        {: return createForMapStatmentPart(%key%, %value%, %map%, %sym.line%, %sym.column%); :}
                        ;


forMapStatPart1     ::= forMapStatPart0:part
                        {: return %part%; :}
                        |IDENTIFIER:label COLON forMapStatPart0:part
                        {: return (%part%).setLabel(getLabelIndex(%label%)); :}
                        ;


forMapStatPart      ::= forMapStatPart1:part blockStat:body
                        {: return (%part%).setBodyStatment(%body%); :}
                        ;


forMapStat          ::= forMapStatPart:part
                        {: return (%part%).pop(); :}
                        |forMapStatPart:part ELSE blockStat:elseBody
                        {: return (%part%).setElseStatment(%elseBody%).pop(); :}
                        ;


whileStatPart0      ::= WHILE:sym LPAREN expression:whileExpr RPAREN
                        {: return new WhileStatmentPart().setWhileExpr(%whileExpr%).setDoWhileAtFirst(true).setPosition(%sym.line%, %sym.column%); :}
                        ;


whileStatPart       ::= whileStatPart0:part blockStat:body
                        {: return (%part%).setBodyStatment(%body%); :}
                        |DO:sym blockStat:body whileStatPart0:part SEMICOLON
                        {: return (%part%).setBodyStatment(%body%).setPosition(%sym.line%, %sym.column%); :}
                        ;


whileStat           ::= whileStatPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label whileStatPart:part
                        {: return (%part%).setLabel(getLabelIndex(%label%)).pop(); :}
                        ;


caseBlockStatPart     ::= 
                        {: return createBlockStatmentPart(-1, -1); :}
                        |caseBlockStatPart:part statment:stat
                        {: return (%part%).append(%stat%); :}
                        ;


caseBlockStat       ::= caseBlockStatPart:bodyPart
                        {: return createBlockStatment(%bodyPart%); :}
                        ;


switchStatPart0      ::= 
                        {: return new SwitchStatmentPart(); :}
                        | CASE:sym directValue:key COLON caseBlockStat:body switchStatPart0:part
                        {: return (%part%).appendCaseStatment(%key%, %body%, %sym.line%, %sym.column%); :}
                        | DEFAULT:sym COLON caseBlockStat:body switchStatPart0:part
                        {: return (%part%).appendCaseStatment(null, %body%, %sym.line%, %sym.column%); :}
                        ;


switchStatPart      ::= SWITCH:sym LPAREN expression:switchExpr RPAREN LBRACE switchStatPart0:part RBRACE
                        {: return (%part%).setSwitchExpr(%switchExpr%).setPosition(%sym.line%, %sym.column%); :}
                        ;


switchStat          ::= switchStatPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON switchStatPart:part
                        {: return (%part%).setLabel(getLabelIndex(%label%)).pop(); :}
                        ;


/* Expressions */

expression_stat ::= 
                    //assignOper = 
                    expression:lexpr EQ:sym expression:expr
                    {: return new AssignOperator(castToResetableValueExpression(%lexpr%, %sym.line%, %sym.column%), %expr%, %sym.line%, %sym.column%); :}
                    | VAR IDENTIFIER:ident EQ:sym expression:expr
                    {: assignVariant(%ident%,%ident.line%,%ident.column%);
        return new AssignOperator(createContextValue(%ident%, %ident.line%, %ident.column%), %expr%, %sym.line%, %sym.column%); :}
                    
                    //plusPlusOper ++
                    |PLUSPLUS:sym expression:expr
                    {: return new PlusPlusBeforeOperator(castToResetableValueExpression(%expr%, %sym.line%, %sym.column%), %sym.line%, %sym.column%); :}
                    |expression:expr PLUSPLUS:sym
                    {: return new PlusPlusAfterOperator(castToResetableValueExpression(%expr%, %sym.line%, %sym.column%), %sym.line%, %sym.column%); :}

                    //minusMinusOper --
                    |MINUSMINUS:sym expression:expr
                    {: return new MinusMinusBeforeOperator(castToResetableValueExpression(%expr%, %sym.line%, %sym.column%), %sym.line%, %sym.column%); :}
                    |expression:expr MINUSMINUS:sym
                    {: return new MinusMinusAfterOperator(castToResetableValueExpression(%expr%, %sym.line%, %sym.column%), %sym.line%, %sym.column%); :}

                    //selfOper
                    |expression:lexpr SELFEQ:sym expression:rexpr
                    {: return createSelfOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    
                    //RedirectOutExpression =>
                    |funcExecuteExpr:srcExpr EQGT:sym expression:expr
                    {: return new RedirectOutExpression(%srcExpr%, castToResetableValueExpression(%expr%, %sym.line%, %sym.column%), %sym.line%, %sym.column%); :}

                    //
                    |funcExecuteExpr:expr    {: return %expr%; :}
                    ;


expression      ::= expression_stat:expr
                    {: return %expr%; :}

                    //bitNotOper ~
                    |COMP:sym expression:expr
                    {: return StatmentUtil.optimize(new BitNotOperator(%expr%, %sym.line%, %sym.column%)); :}
                    
                    //negativeOper  -
                    |MINUS:sym expression:expr
                    {: return StatmentUtil.optimize(new NegativeOperator(%expr%, %sym.line%, %sym.column%)); :}
                    %prec UMINUS
                    
                    //notOper !
                    |NOT:sym expression:expr
                    {: return StatmentUtil.optimize(new NotOperator(%expr%, %sym.line%, %sym.column%)); :}

                    //propertyOper .
                    |expression:expr DOT:sym IDENTIFIER:ident 
                    {: return new PropertyOperator(%expr%, %ident%, %sym.line%, %sym.column%); :}
                    
                    //indexOper []
                    |expression:lexpr LBRACK:sym expression:rexpr RBRACK
                    {: return new IndexOperator(%lexpr%, %rexpr%, %sym.line%, %sym.column%); :}

                    /***********  binarys *************/
                    //-- binary:  *
                    |expression:lexpr MULT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  /
                    |expression:lexpr DIV:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  %
                    |expression:lexpr MOD:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  +
                    |expression:lexpr PLUS:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  -
                    |expression:lexpr MINUS:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <<
                    |expression:lexpr LSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >>
                    |expression:lexpr RSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >>>
                    |expression:lexpr URSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <
                    |expression:lexpr LT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <=
                    |expression:lexpr LTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >
                    |expression:lexpr GT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >=
                    |expression:lexpr GTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ==
                    |expression:lexpr EQEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  !=
                    |expression:lexpr NOTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  &
                    |expression:lexpr AND:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  |
                    |expression:lexpr OR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ^
                    |expression:lexpr XOR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  &&
                    |expression:lexpr ANDAND:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ..
                    |expression:lexpr DOTDOT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ||
                    |expression:lexpr OROR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ?:
                    |expression:lexpr QUESTION_COLON:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}


                    //ifOper ? :
                    |expression:ifexpr QUESTION:sym expression:lexpr COLON expression:rexpr
                    {: return StatmentUtil.optimize(new IfOperator(%ifexpr%, %lexpr%, %rexpr%, %sym.line%, %sym.column%)); :}

                    //
                    |directValue:sym
                    {: return new DirectValue(%sym%, %sym.line%, %sym.column%); :}
                    
                    // ()
                    |LPAREN expression:expr RPAREN
                    {: return %expr%; :}


                    //NativeNewArrayDeclareExpression 
                    |NATIVE:sym LBRACK RBRACK className:nameBand
                    {: return new NativeNewArrayDeclareExpressionPart(toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %sym.line%, %sym.column%).pop(this.engine); :}
                    |NATIVE:sym LBRACK className:nameBand RBRACK
                    {: return new NativeNewArrayDeclareExpressionPart(toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %sym.line%, %sym.column%).pop(this.engine); :}


                    //funcDeclareExpr
                    |funcPart:part RBRACE
                    {: return new FunctionDeclareExpression(
                (%part%).setOverflowUpstairs(varmgr.popVarWall()).setVarMap(varmgr.pop()).pop(),
                %part.line%, %part.column%); :}


                    //arrayValue
                    |arrayValuePart:part RBRACK
                    {: return (%part%).pop(); :}
                    |LBRACK:sym RBRACK
                    {: return new ArrayValue(new Expression[0], %sym.line%,%sym.column%); :}


                    //nativeMethodExpr
                    |nativeMethodExprPart:part RPAREN
                    {: return (%part%).pop(this.engine); :}
                    |nativeMethodExprPart1:part RPAREN
                    {: return (%part%).pop(this.engine); :}

                    //nativeConstructorExpr
                    |nativeConstructorExprPart1:part RPAREN
                    {: return (%part%).pop(this.engine); :}
                    |nativeConstructorExprPart:part RPAREN
                    {: return (%part%).pop(this.engine); :}


                    |contextValueExpr:expr    {: return %expr%; :}
                    |mapValue:expr    {: return %expr%; :}
                    ;


directValue         ::= INTEGER_LITERAL:sym    {: return %sym%; :}
                        |FLOATING_POINT_LITERAL:sym    {: return %sym%; :}
                        |BOOLEAN_LITERAL:sym    {: return %sym%; :}
                        |CHARACTER_LITERAL:sym    {: return %sym%; :}
                        |STRING_LITERAL:sym    {: return %sym%; :}
                        |NULL_LITERAL:sym    {: return %sym%; :}
                        ;


// super
superCount          ::= SUPER DOT
                        {: return 1; :}
                        |superCount:count SUPER DOT
                        {: return %count% + 1; :}
                        ;


// ident  super...ident  this.ident
contextValueIdent   ::= IDENTIFIER:ident
                        {: return %ident%; :}
                        |FOR DOT IDENTIFIER:ident
                        {: return ("for." + %ident%).intern(); :}
                        ;


contextValueExpr    ::= contextValueIdent:ident
                        {: return createContextValue(%ident%, %ident.line%, %ident.column%); :}
                        |THIS DOT contextValueIdent:ident
                        {: return createContextValue(0, %ident%, %ident.line%, %ident.column%); :}
                        |superCount:count contextValueIdent:ident
                        {: return createContextValue(%count%, %ident%, %ident.line%, %ident.column%); :}
                        ;


// array [expr, ...]

arrayValuePart      ::= LBRACK:sym expression:expr
                        {: return new ArrayValuePart(%sym.line%, %sym.column%).append(%expr%); :}
                        |arrayValuePart:part COMMA expression:expr
                        {: return (%part%).append(%expr%); :}
                        ;



// map {key:expr, ...}

mapValuePart        ::= LBRACE:sym directValue:key COLON expression:expr
                        {: return new MapValuePart(%sym.line%, %sym.column%).append(%key%, %expr%); :}
                        |mapValuePart:part COMMA directValue:key COLON expression:expr
                        {: return (%part%).append(%key%, %expr%); :}
                        ;


mapValue            ::= mapValuePart:part RBRACE
                        {: return (%part%).pop(); :}
                        |LBRACE:sym RBRACE
                        {: return new MapValue(new Object[0], new Expression[0], %sym.line%,%sym.column%); :}
                        ;

/* function  */


funcPart0           ::= FUNCTION:sym LPAREN
                        {: pushVarMgrForFunction(); return new FunctionPart(%sym.line%, %sym.column%).setArgsIndex(assignVariant("arguments", %sym.line%, %sym.column%)); :}
                        ;


funcPart1           ::= funcPart0:part IDENTIFIER:ident
                        {: return (%part%).appendArgIndexs(assignVariant(%ident%, %ident.line%, %ident.column%)); :}
                        |funcPart1:part COMMA IDENTIFIER:ident
                        {: return (%part%).appendArgIndexs(assignVariant(%ident%, %ident.line%, %ident.column%)); :}
                        ;


funcPart            ::= funcPart0:part RPAREN LBRACE
                        {: return %part%; :}
                        |funcPart1:part RPAREN LBRACE
                        {: return %part%; :}
                        |funcPart:part statment:stat
                        {: return (%part%).append(%stat%); :}
                        ;


funcExecuteExpr     ::= funcExecuteExprPart0:part RPAREN
                        {: return (%part%).pop(); :}
                        |funcExecuteExprPart1:part RPAREN
                        {: return (%part%).pop(); :}
                        ;


funcExecuteExprPart0    ::= expression:funcExpr LPAREN
                            {: return new FunctionExecuteExpressionPart().setPosition(%funcExpr.line%, %funcExpr.column%).setFuncExpr(%funcExpr%); :}
                            |expression:param0 AT contextValueExpr:funcExpr LPAREN
                            {: return new FunctionExecuteExpressionPart().setPosition(%funcExpr.line%, %funcExpr.column%).setFuncExpr(%funcExpr%).append(%param0%); :}
                            ;


funcExecuteExprPart1    ::= funcExecuteExprPart0:part expression:expr
                            {: return (%part%).append(%expr%); :}
                            |funcExecuteExprPart1:part COMMA expression:expr
                            {: return (%part%).append(%expr%); :}
                            ;




/* Native Method */


nativeMethodExprPart1   ::= NATIVE:sym classPureName:nameBand DOT IDENTIFIER:ident LPAREN
                            {: return new NativeMethodDeclareExpressionPart(%sym.line%, %sym.column%).setClassName(toClass(%nameBand%, %nameBand.line%, %nameBand.column%)).setMethodName(%ident%); :}
                            ;


nativeMethodExprPart    ::= nativeMethodExprPart1:part className:nameBand
                            {: return (%part%).append(toClass(%nameBand%, %nameBand.line%, %nameBand.column%)); :}
                            |nativeMethodExprPart:part COMMA className:nameBand
                            {: return (%part%).append(toClass(%nameBand%, %nameBand.line%, %nameBand.column%)); :}
                            ;



/* Native Constructor */

nativeConstructorExprPart1  ::= NATIVE:sym NEW classPureName:nameBand LPAREN
                                {: return new NativeConstructorDeclareExpressionPart(%sym.line%, %sym.column%).setClassName(toClass(%nameBand%, %nameBand.line%, %nameBand.column%)); :}
                                ;


nativeConstructorExprPart   ::= nativeConstructorExprPart1:part className:nameBand
                                {: return (%part%).append(toClass(%nameBand%, %nameBand.line%, %nameBand.column%)); :}
                                |nativeConstructorExprPart:part COMMA className:nameBand
                                {: return (%part%).append(toClass(%nameBand%, %nameBand.line%, %nameBand.column%)); :}
                                ;


