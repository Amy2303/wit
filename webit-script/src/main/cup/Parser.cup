// Copyright (c) 2013, Webit Team. All Rights Reserved.

package webit.script.core;

import java.util.HashMap;
import java.util.Map;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.method.*;
import webit.script.core.ast.statments.*;
import webit.script.core.java_cup.runtime.Stack;
import webit.script.core.java_cup.runtime.Symbol;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.StatmentUtil;


parser code {:
    public Parser() {
        super(start_state(), _production_table, _action_table, _reduce_table);
    }
    
//    public Parser() {
//        super(start_state(), start_production(), EOF_sym(), error_sym(), _production_table, _action_table, _reduce_table);
//    }

    final boolean isLocateVarForce() {
        return this.locateVarForce;
    }
    
    final Stack<Symbol> getStack() {
        return this._stack;
    }

    final void done_parsing() {
        this.goonParse = false;
    }

    final Statment createTextStatment(char[] text, int line, int column) {
        return StatmentUtil.optimize(textStatmentFactory.getTextStatment(template, text, line, column));
    }
    
    final Statment createPlaceHolderStatment(Expression expr) {
        return StatmentUtil.optimize(placeHolderStatmentFactory.creatPlaceHolderStatment(expr));
    }
    
    final Expression pop(NativeNewArrayDeclareExpressionPart part){
        return part.pop(this.engine);
    }

    final Expression pop(NativeConstructorDeclareExpressionPart part) {
        return part.pop(this.engine);
    }
    
    final Expression pop(NativeMethodDeclareExpressionPart part) {
        return part.pop(this.engine);
    }
:}; 


action code {: 

    //================ >>
    private Map<String, Integer> labelsIndexMap = new HashMap<String, Integer>();
    {
        labelsIndexMap.put(null, 0);
    }
    private int currentLabelIndex = 0;
    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }
    
    NativeImportManager nativeImportMgr = new NativeImportManager();

    private void registClass(ClassNameBand classNameBand, int line, int column) {
        try {
            nativeImportMgr.registClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }
    
    private Class<?> toClass(ClassNameBand classNameBand, int line, int column) {
        try {
            return nativeImportMgr.toClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    //================ >> 

    private VariantManager varmgr = new VariantManager();

    private void pushVarMgrForFunction(){
        varmgr.push();
        varmgr.pushVarWall();
    }

    private int assignVariant(String ident, int line, int column) {
        try {
            return varmgr.assignVariant(ident);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private int assignVariantForNextBlock(String name, int line, int column) {
        try {
            return varmgr.assignVariantForNextBlock(name);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private int locateVarAtUpstairForce(String name, int upstair, int line, int column) {
        try {
            return varmgr.locateAtUpstair(name, upstair, true);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private VarAddress locateVar(String name, int line, int column) {
        try {
            return varmgr.locate(name, parser.isLocateVarForce());
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    //================ >> TemplateAST

    private TemplateASTPart createTemplateASTPart() {
        return new TemplateASTPart();
    }

    private TemplateAST createTemplateAST(TemplateASTPart part) {
        return part.setVarMap(varmgr.pop()).pop();
    }

    //================ >> Statment
    
    private Statment createIncludeStatment(Expression expr,Expression paramExpr, int line, int column){
        return new IncludeStatment(expr, paramExpr, line, column);
    }
                
    private ImportStatmentPart createImportStatmentPart(Expression expr, int line, int column){
        return new ImportStatmentPart(expr, line, column);
    }
        
    private Statment createEchoStatment(Expression expr, int line, int column){
        return new EchoStatment(expr, line, column);
    }
    
    private Statment createReturnStatment(Expression expr, int line, int column){
        return new ReturnStatment(expr, line, column);
    }

    private Statment createBreakStatment(String label, int line, int column) {
        return new BreakStatment(getLabelIndex(label), line, column);
    }

    private Statment createPlaceHolderStatment(Expression expr) {
        return parser.createPlaceHolderStatment(expr);
    }

    private Statment createContinueStatment(String label, int line, int column) {
        return new ContinueStatment(getLabelIndex(label), line, column);
    }

    private SwitchStatmentPart createSwitchStatmentPart(){
        return new SwitchStatmentPart();
    }

    private WhileStatmentPart createWhileStatmentPart(){
        return new WhileStatmentPart();
    }

    private FunctionPart createFunctionPart(int line, int column){
        return new FunctionPart(line, column);
    }

    private IfStatmentPart createIfStatmentPart(Expression ifexpr, int line, int column){
        return new IfStatmentPart(ifexpr, line, column);
    }

    private ForInStatmentPart createForInStatmentPart(String item, Expression items, int line, int column){
        
        int itemIndex = assignVariantForNextBlock(item, line, column);
        int iterIndex = assignVariantForNextBlock("for.iter", line, column);

        return new ForInStatmentPart(itemIndex, iterIndex, items, line, column);
    }

    private ForMapStatmentPart createForMapStatmentPart(String key, String value, Expression map, int line, int column){
        
        int keyIndex = assignVariantForNextBlock(key, line, column);
        int valueIndex = assignVariantForNextBlock(value, line, column);

        int iterIndex = assignVariantForNextBlock("for.iter", line, column);

        return new ForMapStatmentPart(keyIndex, valueIndex, iterIndex, map, line, column);
    }

    private Statment createTextStatment(char[] text, int line, int column) {
        return parser.createTextStatment(text, line, column);
    }

    private BlockStatmentPart createBlockStatmentPart(int line, int column) {
        varmgr.push();
        return new BlockStatmentPart(line, column);
    }

    private IBlockStatment createBlockStatment(BlockStatmentPart part) {

        Map<String, Integer> varMap = varmgr.pop();
        return part.setVarMap(varMap).pop();
    }
    //================ << Statment

    //================ >> Expression

    private ResetableValueExpression createContextValue(String name, int line, int column) {
        VarAddress addr = locateVar(name, line, column);
        return addr.upstairs == 0
                ? new CurrentContextValue(addr.index, name, line, column)
                : new ContextValue(addr.upstairs, addr.index, name, line, column);
    }

    private ResetableValueExpression createContextValue(int upstair, String name, int line, int column) {
        int index = locateVarAtUpstairForce(name, upstair, line, column);
        return upstair == 0
                ? new CurrentContextValue(index, name, line, column)
                : new ContextValue(upstair, index, name, true, line, column);
    }

    private DirectValue createDirectValue(Object value, int line, int column) {
        return new DirectValue(value, line, column);
    }

    private RedirectOutExpression createRedirectOutExpression(Expression srcExpr, Expression rexpr, int line, int column){
        if(rexpr instanceof ResetableValueExpression){
            ResetableValueExpression outExpr = (ResetableValueExpression) rexpr;
            return new RedirectOutExpression(srcExpr, outExpr, line, column);
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", line, column);
        }
    }

    private RedirectOutStatment createRedirectOutStatment(Statment srcStatment, Expression rexpr, int line, int column){
        if(rexpr instanceof ResetableValueExpression){
            ResetableValueExpression outExpr = (ResetableValueExpression) rexpr;
            return new RedirectOutStatment(srcStatment, outExpr, line, column);
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", line, column);
        }
    }

    private FunctionDeclareExpression createFunctionDeclareExpression(FunctionPart part, int line, int column){
        Function function = part.setOverflowUpstairs(varmgr.popVarWall()).setVarMap(varmgr.pop()).pop();
        return new FunctionDeclareExpression(function, line, column);
    }

    private FunctionExecuteExpressionPart createFunctionExecuteExpressionPart(){
        return new FunctionExecuteExpressionPart();
    }

    private NativeMethodDeclareExpressionPart createNativeMethodDeclareExpressionPart(int line, int column){
        return new NativeMethodDeclareExpressionPart(line, column);
    }

    private NativeConstructorDeclareExpressionPart createNativeConstructorDeclareExpressionPart(int line, int column){
        return new NativeConstructorDeclareExpressionPart(line, column);
    }

    private Expression createNativeNewArrayDeclareExpression(Class componentType, int line, int column){
        return parser.pop(new NativeNewArrayDeclareExpressionPart(componentType, line, column));
    }

    //================ >> Expression - Operator
    private Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){

        if(lexpr instanceof ResetableValueExpression){
            ResetableValueExpression leftExpr = (ResetableValueExpression) lexpr;
            SelfOperator oper;
            switch (sym) {

                // (+ - * / %)=
                case Operators.PLUSEQ:
                    oper = new SelfPlusOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.MINUSEQ:
                    oper = new SelfMinusOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.MULTEQ:
                    oper = new SelfMultOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.DIVEQ:
                    oper = new SelfDivOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.MODEQ:
                    oper = new SelfModOperator(leftExpr, rightExpr, line, column);
                    break;

                // (<< >> >>>)=
                case Operators.LSHIFTEQ:
                    oper = new SelfLShiftOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.RSHIFTEQ:
                    oper = new SelfRShiftOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.URSHIFTEQ:
                    oper = new SelfURShiftOperator(leftExpr, rightExpr, line, column);
                    break;

                // (& ^ |)=
                case Operators.ANDEQ:
                    oper = new SelfBitAndOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.XOREQ:
                    oper = new SelfBitXorOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.OREQ:
                    oper = new SelfBitOrOperator(leftExpr, rightExpr, line, column);
                    break;

                default:
                    throw new ParseException("Unsupported Operator", line, column);
            }
            
            return StatmentUtil.optimize(oper);
        }else{
            throw new ParseException("Invalid left expression, must be rewriteable", line, column);
        }
    }

    private Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new AndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new DivOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new EqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new GreaterOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new LessOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new MinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new ModOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new MultOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new OrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new PlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStepOperator(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatmentUtil.optimize(oper);
    }

    private ArrayValuePart createArrayValuePart(Expression expr, int line, int column){
        return new ArrayValuePart(line, column).append(expr);
    }

    private ArrayValue createEmptyArrayValue(int line, int column){
        return new ArrayValue(new Expression[0], line, column);
    }

    private MapValuePart createMapValuePart(Object key, Expression expr, int line, int column){
        return new MapValuePart(line, column).append(key, expr);
    }

    private MapValue createEmptyMapValue(int line, int column){
        return new MapValue(new Object[0], new Expression[0], line, column);
    }

    private Expression createAssignOperator(Expression lexpr, Expression expr, int line, int column) {
        if(lexpr instanceof ResetableValueExpression){
            return StatmentUtil.optimize(new AssignOperator((ResetableValueExpression)lexpr, expr, line, column));
        }else{
            throw new ParseException("Invalid left expression, must be rewriteable", line, column);
        }
    }

    private Expression createIfOperator(Expression ifExpr, Expression leftValueExpr, Expression rightValueExpr, int line, int column) {
        return StatmentUtil.optimize(new IfOperator(ifExpr, leftValueExpr, rightValueExpr, line, column));
    }

    private Expression createIndexOperator(Expression leftExpr, Expression rightExpr, int line, int column) {
        return StatmentUtil.optimize(new IndexOperator(leftExpr, rightExpr, line, column));
    }

    private Expression createNegativeOperator(Expression expr, int line, int column) {
        return StatmentUtil.optimize(new NegativeOperator(expr, line, column));
    }

    private Expression createBitNotOperator(Expression expr, int line, int column) {
        return StatmentUtil.optimize(new BitNotOperator(expr, line, column));
    }

    private Expression createNotOperator(Expression expr, int line, int column) {
        return StatmentUtil.optimize(new NotOperator(expr, line, column));
    }

    private Expression createPropertyOperator(Expression expr, String ident, int line, int column) {
        return StatmentUtil.optimize(new PropertyOperator(expr, ident, line, column));
    }

    private Expression createPlusPlusOperator(Expression expr, boolean executeAtFirst, int line, int column) {
        if(expr instanceof ResetableValueExpression){            
            return executeAtFirst
                    ? new PlusPlusBeforeOperator((ResetableValueExpression)expr, line, column)
                    : new PlusPlusAfterOperator((ResetableValueExpression)expr, line, column);
        }else{
            throw new ParseException("Invalid expression, must be rewriteable", line, column);
        }
    }

    private Expression createMinusMinusOperator(Expression expr, boolean executeAtFirst, int line, int column) {
        if(expr instanceof ResetableValueExpression){
            return executeAtFirst
                    ? new MinusMinusBeforeOperator((ResetableValueExpression)expr, line, column)
                    : new MinusMinusAfterOperator((ResetableValueExpression)expr, line, column);
        }else{
            throw new ParseException("Invalid expression, must be rewriteable", line, column);
        }
    }

    // ==============<< 

:};


/* Terminals */
terminal Integer    VAR,
                    IF, ELSE,
                    FOR, /* IN, */
                    THIS, SUPER,
                    SWITCH, CASE, DEFAULT,
                    DO, WHILE,
                    THROW, TRY, CATCH, FINALLY,
                    NEW,
                    INSTANCEOF,
                    FUNCTION,
                    ECHO,
                    STATIC, NATIVE,
                    IMPORT, INCLUDE, NATIVE_IMPORT,
                    BREAK, CONTINUE, RETURN
                    ;


terminal Integer    PLUSPLUS, MINUSMINUS,  // ++ ==
                    PLUS, MINUS, MULT, DIV, MOD,  // + - * /
                    LSHIFT, RSHIFT, URSHIFT,  // << >> >>>
                    LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ,  // < > <= >= == !=
                    AND, XOR, OR, COMP,  // & ^ | ~
                    ANDAND, OROR, NOT,  // && || !
                    QUESTION, QUESTION_COLON,// ?  ?:
                    SELFEQ,  // (+ - * / %)= (<< >> >>>)= (& ^ |)=
                    UMINUS,
                    DOT,  // .
                    COLON,  // :
                    COMMA,  // ,
                    SEMICOLON,  // ;
                    LBRACE, RBRACE,  // { }
                    LPAREN, RPAREN,  // ( )
                    LBRACK, RBRACK,  // [ ]
                    EQGT,  // =>
                    AT,  // @
                    DOTDOT,  // ..
                    EQ   // =
                    ;


terminal String     IDENTIFIER; // Ident


terminal Number     INTEGER_LITERAL;
terminal Number     FLOATING_POINT_LITERAL;
terminal Boolean    BOOLEAN_LITERAL;
terminal Character  CHARACTER_LITERAL;
terminal String     STRING_LITERAL;

terminal            NULL_LITERAL;


terminal Integer    PLACE_HOLDER_END; // "}"
terminal char[]     TEXT_STATMENT;


/* non terminal */

non terminal directValue;
non terminal ClassNameBand classPureName;
non terminal ClassNameBand className;

/* TemplateAST */
non terminal TemplateAST templateAST;
non terminal TemplateASTPart templateASTPart;


/* function */
non terminal FunctionPart funcPart,funcPart0,funcPart1;

non terminal Expression funcExecuteExpr;

non terminal FunctionExecuteExpressionPart funcExecuteExprPart0, funcExecuteExprPart1;


non terminal NativeMethodDeclareExpressionPart nativeMethodExprPart, nativeMethodExprPart1;

non terminal NativeConstructorDeclareExpressionPart nativeConstructorExprPart1, nativeConstructorExprPart;


/* Statment */

non terminal Statment statment;

non terminal Statment varStatment;
non terminal varStatmentPart;

non terminal Statment includeStat;  // include
non terminal Statment importStat;  // import
non terminal ImportStatmentPart  importStatPart1, importStatPart2;


non terminal BlockStatmentPart blockStatPart;

non terminal IBlockStatment blockStat;
non terminal Statment forInStat;
non terminal Statment ifStat;
non terminal Statment forMapStat;
non terminal Statment whileStat;
non terminal Statment switchStat;


non terminal BlockStatmentPart caseBlockStatPart;
non terminal IBlockStatment caseBlockStat;
non terminal SwitchStatmentPart switchStatPart, switchStatPart0;
non terminal ForInStatmentPart forInStatPart, forInStatPart0, forInStatPart1;
non terminal ForMapStatmentPart forMapStatPart, forMapStatPart0, forMapStatPart1;
non terminal WhileStatmentPart whileStatPart, whileStatPart0;
non terminal IfStatmentPart ifStatPart;


/* special Operators */


non terminal Expression expression;
non terminal Expression expression_stat;


non terminal ArrayValuePart arrayValuePart;

non terminal MapValuePart mapValuePart;
non terminal MapValue mapValue;

/* Operators */

non terminal String contextValueIdent;
non terminal Integer superCount;
non terminal ResetableValueExpression contextValueExpr; // 




/* precedence */

precedence left     SEMICOLON; // ;

precedence right    SELFEQ,  // (+ - * / %)=  (<< >> >>>)=  (& ^ |)=
                    EQ // = 
                    ;

precedence left     DOTDOT;  // ..
precedence right    QUESTION, QUESTION_COLON; // [? : ] ?:
precedence left     OROR; // ||
precedence left     ANDAND; // &&
precedence left     XOR; // ^
precedence left     OR; // |
precedence left     AND; // &
precedence left     EQEQ, NOTEQ; // == !=
precedence left     LT, LTEQ, GT, GTEQ; // < <= > >=  //Unsupport: instanceOf
precedence left     LSHIFT, RSHIFT, URSHIFT; // << >> >>>
precedence left     PLUS, MINUS; // + -
precedence left     MULT, DIV, MOD; // * / %
precedence right    PLUSPLUS, MINUSMINUS, UMINUS, NOT, COMP; // ++ -- - ! ~
precedence left     EQGT;  // =>
precedence left     DOT, LBRACK, LPAREN, LBRACE, AT; // . [ ( { @



/* templateAST */

templateAST            ::= templateASTPart:part
                        {: RESULT = createTemplateAST(part); :}
                        ;


templateASTPart        ::= templateASTPart:part statment:stat
                        {: RESULT = part.append(stat); :}
                        |
                        {: RESULT = createTemplateASTPart(); :}
                        ;


classPureName       ::= IDENTIFIER:ident
                        {: RESULT = new ClassNameBand(ident); :}
                        |classPureName:part DOT IDENTIFIER:ident
                        {: RESULT = part.append(ident); :}
                        ;

className           ::= classPureName:part
                        {: RESULT = part; :}
                        |className:part LBRACK RBRACK
                        {: RESULT = part.plusArrayDepth(); :}
                        ;


/* special Statments  */

statment            ::= expression_stat:expr SEMICOLON
                        {: RESULT = expr; :}
                        |SEMICOLON
                        {: RESULT = NoneStatment.getInstance(); :}
                        |expression:expr PLACE_HOLDER_END
                        {: RESULT = createPlaceHolderStatment(expr); :}
                        |varStatment:stat
                        {: RESULT = stat; :}
                        |blockStat:stat
                        {: RESULT = stat; :}
                        |ifStat:stat
                        {: RESULT = stat; :}
                        |forInStat:stat
                        {: RESULT = stat; :}
                        |forMapStat:stat
                        {: RESULT = stat; :}
                        |whileStat:stat
                        {: RESULT = stat; :}
                        |switchStat:stat
                        {: RESULT = stat; :}
                        |importStat:stat
                        {: RESULT = stat; :}
                        |includeStat:stat
                        {: RESULT = stat; :}

                        //redirectOutStat
                        |blockStat:stat EQGT:sym expression:expr SEMICOLON
                        {: RESULT = createRedirectOutStatment(stat, expr, sym$Symbol.line, sym$Symbol.column); :}

                        //textStat
                        |TEXT_STATMENT:sym
                        {: RESULT = createTextStatment(sym, sym$Symbol.line, sym$Symbol.column); :}

                        //varStatment
                        |varStatmentPart SEMICOLON
                        {: RESULT = NoneStatment.getInstance(); :}

                        //echoStat
                        |ECHO:sym expression:expr SEMICOLON
                        {: RESULT = createEchoStatment(expr, sym$Symbol.line, sym$Symbol.column); :}

                        //@import
                        |NATIVE_IMPORT:sym classPureName:nameBand SEMICOLON
                        {: registClass(nameBand, sym$Symbol.line, sym$Symbol.column); RESULT = NoneStatment.getInstance(); :}
                        //|NATIVE_IMPORT:sym classPureName:nameBand DOT MULT SEMICOLON
                        //{: registPackage(nameBand, sym$Symbol.line, sym$Symbol.column); RESULT = NoneStatment.getInstance(); :}
                        
                        //BREAK
                        |BREAK:sym SEMICOLON
                        {: RESULT = createBreakStatment(null, sym$Symbol.line, sym$Symbol.column); :}
                        |BREAK:sym IDENTIFIER:label SEMICOLON
                        {: RESULT = createBreakStatment(label, sym$Symbol.line, sym$Symbol.column); :}
                        
                        //CONTINUE
                        |CONTINUE:sym SEMICOLON
                        {: RESULT = createContinueStatment(null, sym$Symbol.line, sym$Symbol.column); :}
                        |CONTINUE:sym IDENTIFIER:label SEMICOLON
                        {: RESULT = createContinueStatment(label, sym$Symbol.line, sym$Symbol.column); :}
                        
                        //RETURN
                        |RETURN:sym SEMICOLON
                        {: RESULT = createReturnStatment(null, sym$Symbol.line, sym$Symbol.column); :}
                        |RETURN:sym expression:expr SEMICOLON
                        {: RESULT = createReturnStatment(expr, sym$Symbol.line, sym$Symbol.column); :}
                        ;



varStatmentPart     ::= VAR IDENTIFIER:ident
                        {: assignVariant(ident,ident$Symbol.line,ident$Symbol.column); RESULT = null;:}
                        |varStatmentPart COMMA IDENTIFIER:ident
                        {: assignVariant(ident,ident$Symbol.line,ident$Symbol.column); RESULT = null;:}
                        ;



importStatPart1     ::= IMPORT:sym expression:expr
                        {: RESULT = createImportStatmentPart(expr, sym$Symbol.line, sym$Symbol.column); :}
                        |IMPORT:sym expression:expr mapValue:paramsExpr
                        {: RESULT = createImportStatmentPart(expr, sym$Symbol.line, sym$Symbol.column).setParamsExpr(paramsExpr); :}
                        |IMPORT:sym expression:expr LBRACE expression:paramsExpr RBRACE
                        {: RESULT = createImportStatmentPart(expr, sym$Symbol.line, sym$Symbol.column).setParamsExpr(paramsExpr); :}
                        ;



importStatPart2     ::= importStatPart1:part IDENTIFIER:ident
                        {: RESULT = part.append(ident, createContextValue(ident, ident$Symbol.line, ident$Symbol.column)); :}
                        |importStatPart1:part contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: RESULT = part.append(ident, valueExpr); :}
                        |importStatPart2:part COMMA IDENTIFIER:ident
                        {: RESULT = part.append(ident, createContextValue(ident, ident$Symbol.line, ident$Symbol.column)); :}
                        |importStatPart2:part COMMA contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: RESULT = part.append(ident, valueExpr); :}
                        ;


importStat          ::= importStatPart1:part SEMICOLON
                        {: RESULT = part.pop(); :}
                        |importStatPart2:part SEMICOLON
                        {: RESULT = part.pop(); :}
                        ;


includeStat         ::= INCLUDE:sym expression:expr SEMICOLON
                        {: RESULT = createIncludeStatment(expr, null, sym$Symbol.line, sym$Symbol.column); :}
                        |INCLUDE:sym expression:expr mapValue:paramsExpr SEMICOLON
                        {: RESULT = createIncludeStatment(expr, paramsExpr, sym$Symbol.line, sym$Symbol.column); :}
                        |INCLUDE:sym expression:expr LBRACE expression:paramsExpr RBRACE SEMICOLON
                        {: RESULT = createIncludeStatment(expr, paramsExpr, sym$Symbol.line, sym$Symbol.column); :}
                        ;


blockStatPart       ::= LBRACE:sym // statment:stat
                        {: RESULT = createBlockStatmentPart(sym$Symbol.line, sym$Symbol.column); :}
                        |blockStatPart:part statment:stat
                        {: RESULT = part.append(stat); :}
                        ;


blockStat           ::= blockStatPart:part RBRACE
                        {: RESULT = createBlockStatment(part); :}
                        ;


ifStatPart          ::= IF:sym LPAREN expression:expr RPAREN blockStat:body
                        {: RESULT = createIfStatmentPart(expr, sym$Symbol.line, sym$Symbol.column).setThenStatment(body); :}
                        ;


ifStat              ::= ifStatPart:part
                        {: RESULT = part.pop(); :}
                        |ifStatPart:part ELSE blockStat:elseBody
                        {: RESULT = part.setElseStatment(elseBody).pop(); :}
                        |ifStatPart:part ELSE ifStat:elseBody
                        {: RESULT = part.setElseStatment(elseBody).pop(); :}
                        ;


forInStatPart0        ::= FOR:sym LPAREN IDENTIFIER:item COLON expression:items RPAREN
                        {: RESULT = createForInStatmentPart(item, items, sym$Symbol.line, sym$Symbol.column); :}
                        ;


forInStatPart1     ::= forInStatPart0:part
                        {: RESULT = part; :}
                        |IDENTIFIER:label COLON forInStatPart0:part
                        {: RESULT = part.setLabel(getLabelIndex(label)); :}
                        ;


forInStatPart         ::= forInStatPart1:part blockStat:body
                        {: RESULT = part.setBodyStatment(body); :}
                        ;


forInStat             ::= forInStatPart:part
                        {: RESULT = part.pop(); :}
                        |forInStatPart:part ELSE blockStat:elseBody
                        {: RESULT = part.setElseStatment(elseBody).pop(); :}
                        ;


forMapStatPart0     ::= FOR:sym LPAREN IDENTIFIER:key COMMA IDENTIFIER:value COLON expression:map RPAREN
                        {: RESULT = createForMapStatmentPart(key, value, map, sym$Symbol.line, sym$Symbol.column); :}
                        ;


forMapStatPart1     ::= forMapStatPart0:part
                        {: RESULT = part; :}
                        |IDENTIFIER:label COLON forMapStatPart0:part
                        {: RESULT = part.setLabel(getLabelIndex(label)); :}
                        ;


forMapStatPart      ::= forMapStatPart1:part blockStat:body
                        {: RESULT = part.setBodyStatment(body); :}
                        ;


forMapStat          ::= forMapStatPart:part
                        {: RESULT = part.pop(); :}
                        |forMapStatPart:part ELSE blockStat:elseBody
                        {: RESULT = part.setElseStatment(elseBody).pop(); :}
                        ;


whileStatPart0      ::= WHILE:sym LPAREN expression:whileExpr RPAREN
                        {: RESULT = createWhileStatmentPart().setWhileExpr(whileExpr).setDoWhileAtFirst(true).setPosition(sym$Symbol.line, sym$Symbol.column); :}
                        ;


whileStatPart       ::= whileStatPart0:part blockStat:body
                        {: RESULT = part.setBodyStatment(body); :}
                        |DO:sym blockStat:body whileStatPart0:part SEMICOLON
                        {: RESULT = part.setBodyStatment(body).setPosition(sym$Symbol.line, sym$Symbol.column); :}
                        ;


whileStat           ::= whileStatPart:part
                        {: RESULT = part.pop(); :}
                        |IDENTIFIER:label whileStatPart:part
                        {: RESULT = part.setLabel(getLabelIndex(label)).pop(); :}
                        ;


caseBlockStatPart     ::= 
                        {: RESULT = createBlockStatmentPart(-1, -1); :}
                        |caseBlockStatPart:part statment:stat
                        {: RESULT = part.append(stat); :}
                        ;


caseBlockStat       ::= caseBlockStatPart:bodyPart
                        {: RESULT = createBlockStatment(bodyPart); :}
                        ;


switchStatPart0      ::= 
                        {: RESULT = createSwitchStatmentPart(); :}
                        | CASE:sym directValue:key COLON caseBlockStat:body switchStatPart0:part
                        {: RESULT = part.appendCaseStatment(key, body, sym$Symbol.line, sym$Symbol.column); :}
                        | DEFAULT:sym COLON caseBlockStat:body switchStatPart0:part
                        {: RESULT = part.appendCaseStatment(null, body, sym$Symbol.line, sym$Symbol.column); :}
                        ;


switchStatPart      ::= SWITCH:sym LPAREN expression:switchExpr RPAREN LBRACE switchStatPart0:part RBRACE
                        {: RESULT = part.setSwitchExpr(switchExpr).setPosition(sym$Symbol.line, sym$Symbol.column); :}
                        ;


switchStat          ::= switchStatPart:part
                        {: RESULT = part.pop(); :}
                        |IDENTIFIER:label COLON switchStatPart:part
                        {: RESULT = part.setLabel(getLabelIndex(label)).pop(); :}
                        ;


/* Expressions */

expression_stat ::= 
                    //assignOper = 
                    expression:lexpr EQ:sym expression:expr
                    {: RESULT =  createAssignOperator(lexpr,expr, sym$Symbol.line, sym$Symbol.column); :}
                    | VAR IDENTIFIER:ident EQ:sym expression:expr
                    {: assignVariant(ident,ident$Symbol.line,ident$Symbol.column); ResetableValueExpression valueExpr = createContextValue(ident, ident$Symbol.line, ident$Symbol.column); RESULT = createAssignOperator(valueExpr,expr, sym$Symbol.line, sym$Symbol.column); :}
                    
                    //plusPlusOper ++
                    |PLUSPLUS:sym expression:expr
                    {: RESULT = createPlusPlusOperator(expr, true, sym$Symbol.line, sym$Symbol.column); :}
                    |expression:expr PLUSPLUS:sym
                    {: RESULT = createPlusPlusOperator(expr, false, sym$Symbol.line, sym$Symbol.column); :}

                    //minusMinusOper --
                    |MINUSMINUS:sym expression:expr
                    {: RESULT = createMinusMinusOperator(expr, true, sym$Symbol.line, sym$Symbol.column); :}
                    |expression:expr MINUSMINUS:sym
                    {: RESULT = createMinusMinusOperator(expr, false, sym$Symbol.line, sym$Symbol.column); :}

                    //selfOper
                    |expression:lexpr SELFEQ:sym expression:rexpr
                    {: RESULT = createSelfOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    
                    //RedirectOutExpression =>
                    |funcExecuteExpr:srcExpr EQGT:sym expression:expr
                    {: RESULT = createRedirectOutExpression(srcExpr, expr, sym$Symbol.line, sym$Symbol.column); :}

                    //
                    |funcExecuteExpr:expr    {: RESULT = expr; :}
                    ;


expression      ::= expression_stat:expr
                    {: RESULT = expr; :}

                    //bitNotOper ~
                    |COMP:sym expression:expr
                    {: RESULT = createBitNotOperator(expr, sym$Symbol.line, sym$Symbol.column); :}
                    
                    //negativeOper  -
                    |MINUS:sym expression:expr
                    {: RESULT = createNegativeOperator(expr, sym$Symbol.line, sym$Symbol.column); :}
                    %prec UMINUS
                    
                    //notOper !
                    |NOT:sym expression:expr
                    {: RESULT = createNotOperator(expr, sym$Symbol.line, sym$Symbol.column); :}

                    //propertyOper .
                    |expression:expr DOT:sym IDENTIFIER:ident 
                    {: RESULT = createPropertyOperator(expr, ident, sym$Symbol.line, sym$Symbol.column); :}
                    
                    //indexOper []
                    |expression:lexpr LBRACK:sym expression:rexpr RBRACK
                    {: RESULT = createIndexOperator(lexpr, rexpr, sym$Symbol.line, sym$Symbol.column); :}

                    /***********  binarys *************/
                    //-- binary:  *
                    |expression:lexpr MULT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  /
                    |expression:lexpr DIV:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  %
                    |expression:lexpr MOD:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  +
                    |expression:lexpr PLUS:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  -
                    |expression:lexpr MINUS:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  <<
                    |expression:lexpr LSHIFT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  >>
                    |expression:lexpr RSHIFT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  >>>
                    |expression:lexpr URSHIFT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  <
                    |expression:lexpr LT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  <=
                    |expression:lexpr LTEQ:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  >
                    |expression:lexpr GT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  >=
                    |expression:lexpr GTEQ:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  ==
                    |expression:lexpr EQEQ:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  !=
                    |expression:lexpr NOTEQ:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  &
                    |expression:lexpr AND:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  |
                    |expression:lexpr OR:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  ^
                    |expression:lexpr XOR:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  &&
                    |expression:lexpr ANDAND:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  ..
                    |expression:lexpr DOTDOT:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  ||
                    |expression:lexpr OROR:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}
                    //-- binary:  ?:
                    |expression:lexpr QUESTION_COLON:sym expression:rexpr
                    {: RESULT = createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column); :}


                    //ifOper ? :
                    |expression:ifexpr QUESTION:sym expression:lexpr COLON expression:rexpr
                    {: RESULT = createIfOperator(ifexpr, lexpr, rexpr, sym$Symbol.line, sym$Symbol.column); :}

                    //
                    |directValue:sym
                    {: RESULT = createDirectValue(sym, sym$Symbol.line, sym$Symbol.column); :}
                    
                    // ()
                    |LPAREN expression:expr RPAREN
                    {: RESULT = expr; :}


                    //NativeNewArrayDeclareExpression 
                    |NATIVE:sym LBRACK RBRACK className:nameBand 
                    {: RESULT = createNativeNewArrayDeclareExpression(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column); :}
                    |NATIVE:sym LBRACK className:nameBand RBRACK
                    {: RESULT = createNativeNewArrayDeclareExpression(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column); :}


                    //funcDeclareExpr
                    |funcPart:part RBRACE
                    {: RESULT = createFunctionDeclareExpression(part, part$Symbol.line, part$Symbol.column); :}


                    //arrayValue
                    |arrayValuePart:part RBRACK
                    {: RESULT = part.pop(); :}
                    |LBRACK:sym RBRACK
                    {: RESULT = createEmptyArrayValue(sym$Symbol.line,sym$Symbol.column); :}


                    //nativeMethodExpr
                    |nativeMethodExprPart:part RPAREN
                    {: RESULT = parser.pop(part); :}
                    |nativeMethodExprPart1:part RPAREN
                    {: RESULT = parser.pop(part); :}


                    //nativeConstructorExpr
                    |nativeConstructorExprPart1:part RPAREN
                    {: RESULT = parser.pop(part); :}
                    |nativeConstructorExprPart:part RPAREN
                    {: RESULT = parser.pop(part); :}


                    |contextValueExpr:expr    {: RESULT = expr; :}
                    |mapValue:expr    {: RESULT = expr; :}
                    ;


directValue         ::= INTEGER_LITERAL:sym    {: RESULT = sym; :}
                        |FLOATING_POINT_LITERAL:sym    {: RESULT = sym; :}
                        |BOOLEAN_LITERAL:sym    {: RESULT = sym; :}
                        |CHARACTER_LITERAL:sym    {: RESULT = sym; :}
                        |STRING_LITERAL:sym    {: RESULT = sym; :}
                        |NULL_LITERAL:sym    {: RESULT = sym; :}
                        ;


// super
superCount          ::= SUPER DOT
                        {: RESULT = 1; :}
                        |superCount:count SUPER DOT
                        {: RESULT = count + 1; :}
                        ;


// ident  super...ident  this.ident
contextValueIdent   ::= IDENTIFIER:ident
                        {: RESULT = ident; :}
                        |FOR DOT IDENTIFIER:ident
                        {: RESULT = ("for."+ident).intern(); :}
                        ;

contextValueExpr    ::= contextValueIdent:ident
                        {: RESULT = createContextValue(ident, ident$Symbol.line, ident$Symbol.column); :}
                        |THIS DOT contextValueIdent:ident
                        {: RESULT = createContextValue(0, ident, ident$Symbol.line, ident$Symbol.column); :}
                        |superCount:count contextValueIdent:ident
                        {: RESULT = createContextValue(count, ident, ident$Symbol.line, ident$Symbol.column); :}
                        ;


// array [expr, ...]

arrayValuePart      ::= LBRACK:sym expression:expr
                        {: RESULT = createArrayValuePart(expr, sym$Symbol.line, sym$Symbol.column); :}
                        |arrayValuePart:part COMMA expression:expr
                        {: RESULT = part.append(expr); :}
                        ;



// map {key:expr, ...}

mapValuePart        ::= LBRACE:sym directValue:key COLON expression:expr
                        {: RESULT = createMapValuePart(key, expr, sym$Symbol.line, sym$Symbol.column); :}
                        |mapValuePart:part COMMA directValue:key COLON expression:expr
                        {: RESULT = part.append(key, expr); :}
                        ;


mapValue            ::= mapValuePart:part RBRACE
                        {: RESULT = part.pop(); :}
                        |LBRACE:sym RBRACE
                        {: RESULT = createEmptyMapValue(sym$Symbol.line,sym$Symbol.column); :}
                        ;

/* function  */


funcPart0           ::= FUNCTION:sym LPAREN
                        {: pushVarMgrForFunction(); int argsIndex = assignVariant("arguments", sym$Symbol.line, sym$Symbol.column); RESULT = createFunctionPart(sym$Symbol.line, sym$Symbol.column).setArgsIndex(argsIndex); :}
                        ;


funcPart1           ::= funcPart0:part IDENTIFIER:ident
                        {: int paramIndex = assignVariant(ident, ident$Symbol.line, ident$Symbol.column); RESULT = part.appendArgIndexs(paramIndex); :}
                        |funcPart1:part COMMA IDENTIFIER:ident
                        {: int paramIndex = assignVariant(ident, ident$Symbol.line, ident$Symbol.column); RESULT = part.appendArgIndexs(paramIndex); :}
                        ;


funcPart            ::= funcPart0:part RPAREN LBRACE
                        {: RESULT = part; :}
                        |funcPart1:part RPAREN LBRACE
                        {: RESULT = part; :}
                        |funcPart:part statment:stat
                        {: RESULT = part.append(stat); :}
                        ;


funcExecuteExpr     ::= funcExecuteExprPart0:part RPAREN
                        {: RESULT = part.pop(); :}
                        |funcExecuteExprPart1:part RPAREN
                        {: RESULT = part.pop(); :}
                        ;


funcExecuteExprPart0    ::= expression:funcExpr LPAREN
                            {: RESULT = createFunctionExecuteExpressionPart().setPosition(funcExpr$Symbol.line, funcExpr$Symbol.column).setFuncExpr(funcExpr); :}
                            |expression:param0 AT contextValueExpr:funcExpr LPAREN
                            {: RESULT = createFunctionExecuteExpressionPart().setPosition(funcExpr$Symbol.line, funcExpr$Symbol.column).setFuncExpr(funcExpr).append(param0); :}
                            ;


funcExecuteExprPart1    ::= funcExecuteExprPart0:part expression:expr
                            {: RESULT = part.append(expr); :}
                            |funcExecuteExprPart1:part COMMA expression:expr
                            {: RESULT = part.append(expr); :}
                            ;




/* Native Method */


nativeMethodExprPart1   ::= NATIVE:sym classPureName:nameBand DOT IDENTIFIER:ident LPAREN
                            {: RESULT = createNativeMethodDeclareExpressionPart(sym$Symbol.line, sym$Symbol.column).setClassName(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)).setMethodName(ident); :}
                            ;


nativeMethodExprPart    ::= nativeMethodExprPart1:part className:nameBand
                            {: RESULT = part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)); :}
                            |nativeMethodExprPart:part COMMA className:nameBand
                            {: RESULT = part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)); :}
                            ;



/* Native Constructor */

nativeConstructorExprPart1  ::= NATIVE:sym NEW classPureName:nameBand LPAREN
                                {: RESULT = createNativeConstructorDeclareExpressionPart(sym$Symbol.line, sym$Symbol.column).setClassName(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)); :}
                                ;


nativeConstructorExprPart   ::= nativeConstructorExprPart1:part className:nameBand
                                {: RESULT = part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)); :}
                                |nativeConstructorExprPart:part COMMA className:nameBand
                                {: RESULT = part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)); :}
                                ;


