// Copyright (c) 2013, Webit Team. All Rights Reserved.

package webit.script.core;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import webit.script.asm.AsmMethodCaller;
import webit.script.asm.AsmMethodCallerManager;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.method.*;
import webit.script.core.ast.statments.*;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.ClassUtil;
import webit.script.util.StatmentUtil;
import webit.script.util.StringUtil;
import webit.script.util.collection.Stack;


parser code {:

    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }

    private Expression createContextValue(VarAddress addr, int line, int column) {
        if (addr.isRoot) {
            return new RootContextValue(addr.index, line, column);
        } else if (addr.upstairs == 0) {
            return new CurrentContextValue(addr.index,  line, column);
        } else {
            return new ContextValue(addr.upstairs, addr.index, line, column);
        }
    }
    
    private Expression createContextValueAtUpstair(int upstair, String name, int line, int column) {
        return createContextValue(varmgr.locateAtUpstair(name, upstair, line, column), line, column);
    }
    
    private Expression createContextValue(int upstair, String name, int line, int column) {
        return createContextValue(varmgr.locate(name, upstair, this.locateVarForce, line, column), line, column);
    }

    private CommonMethodDeclareExpression popNativeNewArrayDeclare(Class componentType, int line, int column) {
        Class classWaitCheck = componentType;
        while (classWaitCheck.isArray()) {
            classWaitCheck = classWaitCheck.getComponentType();
        }

        if (classWaitCheck == Void.class || classWaitCheck == Void.TYPE) {
            throw new ParseException("ComponentType must not Void.class", line, column);
        }

        final String path;
        if (engine.checkNativeAccess(path = (classWaitCheck.getName().concat(".[]"))) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }

        return new CommonMethodDeclareExpression(new NativeNewArrayDeclare(componentType), line, column);
    }

    private CommonMethodDeclareExpression popNativeMethodDeclare(Class clazz, String methodName, ClassNameList list, int line, int column) {

        final String path;
        if (engine.checkNativeAccess(path = (StringUtil.concat(clazz.getName(), ".", methodName))) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }

        try {
            final Method method = ClassUtil.searchMethod(clazz, methodName, list.toArray(), false);
            AsmMethodCaller caller;
            if (engine.isEnableAsmNative()) {
                if (ClassUtil.isPublic(clazz)) {
                    if (ClassUtil.isPublic(method)) {
                        try {
                            if ((caller = AsmMethodCallerManager.getCaller(method)) == null) {
                                logger.error(StringUtil.concat("AsmMethodCaller for '", method.toString(), "' is null, and instead by NativeMethodDeclare"));
                            }
                        } catch (Exception ex) {
                            caller = null;
                            logger.error(StringUtil.concat("Generate AsmMethodCaller for '", method.toString(), "' failed, and instead by NativeMethodDeclare"), ex);
                        }
                    } else {
                        logger.warn(StringUtil.concat("'", method.toString(), "' will not use asm, since this method is not public, and instead by NativeMethodDeclare"));
                        caller = null;
                    }
                } else {
                    logger.warn(StringUtil.concat("'", method.toString(), "' will not use asm, since class is not public, and instead by NativeMethodDeclare"));
                    caller = null;
                }
            } else {
                caller = null;
            }

            return new CommonMethodDeclareExpression(caller != null
                    ? new AsmNativeMethodDeclare(caller)
                    : new NativeMethodDeclare(method),
                    line, column);

        } catch (NoSuchMethodException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        } catch (SecurityException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        }
    }

    @SuppressWarnings("unchecked")
    private CommonMethodDeclareExpression popNativeConstructorDeclare(Class clazz, ClassNameList list, int line, int column) {

        final String path;
        if (engine.checkNativeAccess(path = (clazz.getName() + ".<init>")) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }

        try {
            final Constructor constructor = clazz.getConstructor(list.toArray());
            AsmMethodCaller caller;
            if (engine.isEnableAsmNative()) {
                if (ClassUtil.isPublic(clazz)) {
                    if (ClassUtil.isPublic(constructor)) {
                        try {
                            if ((caller = AsmMethodCallerManager.getCaller(constructor)) == null) {
                                logger.error(StringUtil.concat("AsmMethodCaller for '", constructor.toString(), "' is null, and instead by NativeConstructorDeclare"));
                            }
                        } catch (Exception ex) {
                            caller = null;
                            logger.error(StringUtil.concat("Generate AsmMethodCaller for '", constructor.toString(), "' failed, and instead by NativeConstructorDeclare"), ex);
                        }
                    } else {
                        logger.warn(StringUtil.concat("'", constructor.toString(), "' will not use asm, since this method is not public, and instead by NativeConstructorDeclare"));
                        caller = null;
                    }
                } else {
                    logger.warn(StringUtil.concat("'" + constructor.toString() + "' will not use asm, since class is not public, and instead by NativeConstructorDeclare"));
                    caller = null;
                }
            } else {
                caller = null;
            }

            return new CommonMethodDeclareExpression(caller != null
                    ? new AsmNativeMethodDeclare(caller)
                    : new NativeConstructorDeclare(constructor),
                    line, column);

        } catch (NoSuchMethodException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        } catch (SecurityException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        }
    }

    private static ResetableValueExpression castToResetableValueExpression(Expression expr) {
        if(expr instanceof ResetableValueExpression){
            return (ResetableValueExpression) expr;
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", expr);
        }
    }

    private static Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){
        ResetableValueExpression leftExpr = castToResetableValueExpression(lexpr);
        SelfOperator oper;
        switch (sym) {

            // (+ - * / %)=
            case Operators.PLUSEQ:
                oper = new SelfPlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MINUSEQ:
                oper = new SelfMinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MULTEQ:
                oper = new SelfMultOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.DIVEQ:
                oper = new SelfDivOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MODEQ:
                oper = new SelfModOperator(leftExpr, rightExpr, line, column);
                break;

            // (<< >> >>>)=
            case Operators.LSHIFTEQ:
                oper = new SelfLShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.RSHIFTEQ:
                oper = new SelfRShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.URSHIFTEQ:
                oper = new SelfURShiftOperator(leftExpr, rightExpr, line, column);
                break;

            // (& ^ |)=
            case Operators.ANDEQ:
                oper = new SelfBitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.XOREQ:
                oper = new SelfBitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.OREQ:
                oper = new SelfBitOrOperator(leftExpr, rightExpr, line, column);
                break;

            default:
                throw new ParseException("Unsupported Operator", line, column);
        }

        return StatmentUtil.optimize(oper);
    }

    private static Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new AndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new DivOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new EqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new GreaterOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new LessOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new MinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new ModOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new MultOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new OrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new PlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStepOperator(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatmentUtil.optimize(oper);
    }

:};


/* Terminals */
terminal Integer    VAR,
                    IF, ELSE,
                    FOR, /* IN, */
                    THIS, SUPER,
                    SWITCH, CASE, DEFAULT,
                    DO, WHILE,
                    THROW, TRY, CATCH, FINALLY,
                    NEW,
                    INSTANCEOF,
                    FUNCTION,
                    ECHO,
                    STATIC, NATIVE,
                    IMPORT, INCLUDE, NATIVE_IMPORT,
                    BREAK, CONTINUE, RETURN,

                    PLUSPLUS, MINUSMINUS,  // ++ ==
                    PLUS, MINUS, MULT, DIV, MOD,  // + - * /
                    LSHIFT, RSHIFT, URSHIFT,  // << >> >>>
                    LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ,  // < > <= >= == !=
                    AND, XOR, OR, COMP,  // & ^ | ~
                    ANDAND, OROR, NOT,  // && || !
                    QUESTION, QUESTION_COLON,// ?  ?:
                    SELFEQ,  // (+ - * / %)= (<< >> >>>)= (& ^ |)=
                    UMINUS,
                    DOT,  // .
                    COLON,  // :
                    COMMA,  // ,
                    SEMICOLON,  // ;
                    LBRACE, RBRACE, PLACE_HOLDER_END, // { }
                    LPAREN, RPAREN,  // ( )
                    LBRACK, RBRACK,  // [ ]
                    EQGT,  // =>
                    AT,  // @
                    DOTDOT,  // ..
                    EQ   // =
                    ;


terminal String     IDENTIFIER; // Ident
terminal char[]     TEXT_STATMENT;
terminal Object     DIRECT_VALUE;



/* non terminal */
non terminal ClassNameBand classPureName, className;

/* TemplateAST */
non terminal TemplateAST templateAST;

/* Statment */
non terminal StatmentList statmentList;

non terminal Statment statment, ifStat;
non terminal IBlockStatment blockStat, caseBlockStat;
non terminal Object varStatmentPart;
non terminal ImportStatmentPart importStatPart1, importStatPart2;
non terminal Object blockStatPrepare, blockStatPrepare2;
non terminal SwitchStatmentPart switchStatPart, switchStatPart0;
non terminal AbstractForInStatmentPart forInStatHead, forInStatBody, forInStatPart;
non terminal WhileStatmentPart whileStatPart;
non terminal IfStatmentPart ifStatPart;

/* Expression */
non terminal Expression expression, expression_statmentable;
non terminal ExpressionList expressionList, expressionList1;
non terminal MapValuePart mapValuePart;
non terminal MapValue mapValue;

non terminal String contextValueIdent;
non terminal Integer superCount;
non terminal ResetableValueExpression contextValueExpr;
non terminal ClassNameList classNameList, classNameList1;

/* function */
non terminal Expression funcExecuteExpr;
non terminal FunctionPart funcHeadPrepare, funcHead;


/* precedence */
precedence left     SEMICOLON; // ;
precedence right    SELFEQ, EQ; // (+ - * / %)=  (<< >> >>>)=  (& ^ |)=  = 
precedence left     DOTDOT;  // ..
precedence right    QUESTION, QUESTION_COLON; // [? : ] ?:
precedence left     OROR; // ||
precedence left     ANDAND; // &&
precedence left     XOR; // ^
precedence left     OR; // |
precedence left     AND; // &
precedence left     EQEQ, NOTEQ; // == !=
precedence left     LT, LTEQ, GT, GTEQ; // < <= > >=  //Unsupport: instanceOf
precedence left     LSHIFT, RSHIFT, URSHIFT; // << >> >>>
precedence left     PLUS, MINUS; // + -
precedence left     MULT, DIV, MOD; // * / %
precedence right    PLUSPLUS, MINUSMINUS, UMINUS, NOT, COMP; // ++ -- - ! ~
precedence left     EQGT;  // =>
precedence left     DOT, LBRACK, LPAREN, LBRACE, AT; // . [ ( { @



/* templateAST */

templateAST            ::= statmentList:list
                        {: return (%list%).popTemplateAST(varmgr.pop()); :}
                        ;

statmentList           ::= 
                        {: return new StatmentList(); :}
                        |statmentList:list statment:stat
                        {: return (%list%).add(%stat%); :}
                        ;


classPureName       ::= IDENTIFIER:ident
                        {: return new ClassNameBand(%ident%); :}
                        |classPureName:part DOT IDENTIFIER:ident
                        {: return (%part%).append(%ident%); :}
                        ;

className           ::= classPureName:part
                        {: return %part%; :}
                        |className:part LBRACK RBRACK
                        {: return (%part%).plusArrayDepth(); :}
                        ;


/* Statments  */
statment            ::= expression_statmentable:expr SEMICOLON
                        {: return %expr%; :}

                        |SEMICOLON
                        {: return NoneStatment.getInstance(); :}

                        |expression:expr PLACE_HOLDER_END
                        {: return placeHolderStatmentFactory.creatPlaceHolderStatment(%expr%); :}

                        |blockStat:stat
                        {: return %stat%; :}

                        |ifStat:stat
                        {: return %stat%; :}

                        //switchStat
                        |switchStatPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON switchStatPart:part
                        {: return (%part%).pop(getLabelIndex(%label%)); :}
                        
                        //whileStat
                        |whileStatPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON whileStatPart:part
                        {: return (%part%).pop(getLabelIndex(%label%)); :}

                        //forInStat
                        |forInStatPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON forInStatPart:part
                        {: return (%part%).pop(getLabelIndex(%label%)); :}

                        //redirectOutStat
                        |blockStat:stat EQGT:sym expression:expr SEMICOLON
                        {: return new RedirectOutStatment(%stat%, castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                        //textStat
                        |TEXT_STATMENT:sym
                        {: return textStatmentFactory.getTextStatment(template, %sym%, %sym.line%, %sym.column%); :}

                        //varStatment
                        |varStatmentPart SEMICOLON
                        {: return NoneStatment.getInstance(); :}

                        //echoStat
                        |ECHO:sym expression:expr SEMICOLON
                        {: return new EchoStatment(%expr%, %sym.line%, %sym.column%); :}

                        //@import
                        |NATIVE_IMPORT:sym classPureName:nameBand SEMICOLON
                        {: nativeImportMgr.registClass(%nameBand%, %sym.line%, %sym.column%); return NoneStatment.getInstance(); :}
                        
                        //BREAK
                        |BREAK:sym SEMICOLON
                        {: return new BreakStatment(0, %sym.line%, %sym.column%); :}
                        |BREAK:sym IDENTIFIER:label SEMICOLON
                        {: return new BreakStatment(getLabelIndex(%label%), %sym.line%, %sym.column%); :}
                        
                        //CONTINUE
                        |CONTINUE:sym SEMICOLON
                        {: return new ContinueStatment(0, %sym.line%, %sym.column%); :}
                        |CONTINUE:sym IDENTIFIER:label SEMICOLON
                        {: return new ContinueStatment(getLabelIndex(%label%), %sym.line%, %sym.column%); :}
                        
                        //RETURN
                        |RETURN:sym SEMICOLON
                        {: return new ReturnStatment(null, %sym.line%, %sym.column%); :}
                        |RETURN:sym expression:expr SEMICOLON
                        {: return new ReturnStatment(%expr%, %sym.line%, %sym.column%); :}

                        //importStat
                        |importStatPart1:part SEMICOLON
                        {: return (%part%).pop(); :}
                        |importStatPart2:part SEMICOLON
                        {: return (%part%).pop(); :}

                        //includeStat
                        |INCLUDE:sym expression:expr SEMICOLON
                        {: return new IncludeStatment(%expr%, null, %sym.line%, %sym.column%); :}
                        |INCLUDE:sym expression:expr mapValue:paramsExpr SEMICOLON
                        {: return new IncludeStatment(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        |INCLUDE:sym expression:expr LBRACE expression:paramsExpr RBRACE SEMICOLON
                        {: return new IncludeStatment(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        ;


varStatmentPart     ::= VAR IDENTIFIER:ident
                        {: varmgr.assignVariant(%ident%,%ident.line%,%ident.column%); return null;:}
                        |varStatmentPart COMMA IDENTIFIER:ident
                        {: varmgr.assignVariant(%ident%,%ident.line%,%ident.column%); return null;:}
                        ;


importStatPart1     ::= IMPORT:sym expression:expr
                        {: return new ImportStatmentPart(%expr%, %sym.line%, %sym.column%); :}
                        |IMPORT:sym expression:expr mapValue:paramsExpr
                        {: return new ImportStatmentPart(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        |IMPORT:sym expression:expr LBRACE expression:paramsExpr RBRACE
                        {: return new ImportStatmentPart(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        ;


importStatPart2     ::= importStatPart1:part IDENTIFIER:ident
                        {: return (%part%).append(%ident%, createContextValue(0, %ident%, %ident.line%, %ident.column%)); :}
                        |importStatPart1:part contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: return (%part%).append(%ident%, %valueExpr%); :}
                        |importStatPart2:part COMMA IDENTIFIER:ident
                        {: return (%part%).append(%ident%, createContextValue(0, %ident%, %ident.line%, %ident.column%)); :}
                        |importStatPart2:part COMMA contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: return (%part%).append(%ident%, %valueExpr%); :}
                        ;


blockStatPrepare      ::= 
                        {: varmgr.push(); return null; :}
                        ;
blockStatPrepare2      ::= LBRACE
                        {: varmgr.push(); return null; :}
                        ;


blockStat           ::= blockStatPrepare2:prepare statmentList:list RBRACE
                        {: return (%list%).popIBlockStatment(varmgr.pop(), %prepare.line%, %prepare.column%); :}
                        ;


ifStatPart          ::= IF:sym LPAREN expression:expr RPAREN blockStat:body
                        {: return new IfStatmentPart(%expr%, %body%, %sym.line%, %sym.column%); :}
                        ;


ifStat              ::= ifStatPart:part
                        {: return (%part%).pop(); :}
                        |ifStatPart:part ELSE blockStat:elseBody
                        {: return (%part%).pop(%elseBody%); :}
                        |ifStatPart:part ELSE ifStat:elseBody
                        {: return (%part%).pop(%elseBody%); :}
                        ;


forInStatHead       ::= FOR:sym LPAREN IDENTIFIER:item COLON expression:items RPAREN
                        {: return new ForInStatmentPart(%item%, %items%, this.varmgr, %sym.line%, %sym.column%); :}
                        |FOR:sym LPAREN IDENTIFIER:key COMMA IDENTIFIER:value COLON expression:map RPAREN
                        {: return new ForMapStatmentPart(%key%, %value%, %map%, this.varmgr, %sym.line%, %sym.column%); :}
                        ;


forInStatBody       ::= forInStatHead:part LBRACE statmentList:list RBRACE
                        {: return (%part%).setStatmentList(%list%); :}
                        ;


forInStatPart       ::= forInStatBody:part
                        {: return %part%; :}
                        |forInStatBody:part ELSE blockStat:elseBody
                        {: return (%part%).setElseStatment(%elseBody%); :}
                        ;


whileStatPart       ::= WHILE:sym LPAREN expression:whileExpr RPAREN blockStat:body
                        {: return new WhileStatmentPart(%whileExpr%, %body%, true, %sym.line%, %sym.column%); :}
                        |DO:sym blockStat:body WHILE LPAREN expression:whileExpr RPAREN SEMICOLON
                        {: return new WhileStatmentPart(%whileExpr%, %body%, false, %sym.line%, %sym.column%); :}
                        ;


caseBlockStat       ::= blockStatPrepare:prepare statmentList:list
                        {: return (%list%).popIBlockStatment(varmgr.pop(), %prepare.line%, %prepare.column%); :}
                        ;


switchStatPart0      ::= 
                        {: return new SwitchStatmentPart(); :}
                        | CASE:sym DIRECT_VALUE:key COLON caseBlockStat:body switchStatPart0:part
                        {: return (%part%).appendCaseStatment(%key%, %body%, %sym.line%, %sym.column%); :}
                        | DEFAULT:sym COLON caseBlockStat:body switchStatPart0:part
                        {: return (%part%).appendCaseStatment(null, %body%, %sym.line%, %sym.column%); :}
                        ;


switchStatPart      ::= SWITCH:sym LPAREN expression:switchExpr RPAREN LBRACE switchStatPart0:part RBRACE
                        {: return (%part%).setSwitchExpr(%switchExpr%, %sym.line%, %sym.column%); :}
                        ;



/* Expressions */

expression_statmentable ::= 
                    //assignOper = 
                    expression:lexpr EQ:sym expression:expr
                    {: return new AssignOperator(castToResetableValueExpression(%lexpr%), %expr%, %sym.line%, %sym.column%); :}
                    | VAR IDENTIFIER:ident EQ:sym expression:expr
                    {: return new AssignOperator(castToResetableValueExpression(createContextValue(varmgr.assignVariantAddress(%ident%,%ident.line%,%ident.column%), %ident.line%, %ident.column%)), %expr%, %sym.line%, %sym.column%); :}
                    
                    //plusPlusOper ++
                    |PLUSPLUS:sym expression:expr
                    {: return new PlusPlusBeforeOperator(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}
                    |expression:expr PLUSPLUS:sym
                    {: return new PlusPlusAfterOperator(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                    //minusMinusOper --
                    |MINUSMINUS:sym expression:expr
                    {: return new MinusMinusBeforeOperator(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}
                    |expression:expr MINUSMINUS:sym
                    {: return new MinusMinusAfterOperator(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                    //selfOper
                    |expression:lexpr SELFEQ:sym expression:rexpr
                    {: return createSelfOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    
                    //RedirectOutExpression =>
                    |funcExecuteExpr:srcExpr EQGT:sym expression:expr
                    {: return new RedirectOutExpression(%srcExpr%, castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                    //
                    |funcExecuteExpr:expr    {: return %expr%; :}
                    ;


expression      ::= expression_statmentable:expr
                    {: return %expr%; :}

                    //bitNotOper ~
                    |COMP:sym expression:expr
                    {: return StatmentUtil.optimize(new BitNotOperator(%expr%, %sym.line%, %sym.column%)); :}
                    
                    //negativeOper  -
                    |MINUS:sym expression:expr
                    {: return StatmentUtil.optimize(new NegativeOperator(%expr%, %sym.line%, %sym.column%)); :}
                    %prec UMINUS
                    
                    //notOper !
                    |NOT:sym expression:expr
                    {: return StatmentUtil.optimize(new NotOperator(%expr%, %sym.line%, %sym.column%)); :}

                    //propertyOper .
                    |expression:expr DOT:sym IDENTIFIER:ident 
                    {: return new PropertyOperator(%expr%, %ident%, %sym.line%, %sym.column%); :}
                    
                    //indexOper []
                    |expression:lexpr LBRACK:sym expression:rexpr RBRACK
                    {: return new IndexOperator(%lexpr%, %rexpr%, %sym.line%, %sym.column%); :}

                    /***********  binarys *************/
                    //-- binary:  *
                    |expression:lexpr MULT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  /
                    |expression:lexpr DIV:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  %
                    |expression:lexpr MOD:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  +
                    |expression:lexpr PLUS:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  -
                    |expression:lexpr MINUS:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <<
                    |expression:lexpr LSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >>
                    |expression:lexpr RSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >>>
                    |expression:lexpr URSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <
                    |expression:lexpr LT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <=
                    |expression:lexpr LTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >
                    |expression:lexpr GT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >=
                    |expression:lexpr GTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ==
                    |expression:lexpr EQEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  !=
                    |expression:lexpr NOTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  &
                    |expression:lexpr AND:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  |
                    |expression:lexpr OR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ^
                    |expression:lexpr XOR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  &&
                    |expression:lexpr ANDAND:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ..
                    |expression:lexpr DOTDOT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ||
                    |expression:lexpr OROR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ?:
                    |expression:lexpr QUESTION_COLON:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}

                    //ifOper ? :
                    |expression:ifexpr QUESTION:sym expression:lexpr COLON expression:rexpr
                    {: return new IfOperator(%ifexpr%, %lexpr%, %rexpr%, %sym.line%, %sym.column%); :}

                    //
                    |DIRECT_VALUE:sym
                    {: return new DirectValue(%sym%, %sym.line%, %sym.column%); :}
                    
                    // ()
                    |LPAREN expression:expr RPAREN
                    {: return %expr%; :}

                    //funcDeclareExpr
                    |funcHeadPrepare:part RPAREN LBRACE statmentList:list RBRACE
                    {: return (%part%).pop(varmgr, %list%); :}
                    |funcHead:part RPAREN LBRACE statmentList:list RBRACE
                    {: return (%part%).pop(varmgr, %list%); :}


                    //arrayValue
                    |LBRACK:sym expressionList:list RBRACK
                    {: return new ArrayValue((%list%).toArray(), %sym.line%, %sym.column%); :}


                    //NativeNewArrayDeclareExpression 
                    |NATIVE:sym LBRACK RBRACK className:nameBand
                    {: return popNativeNewArrayDeclare(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %sym.line%, %sym.column%); :}
                    |NATIVE:sym LBRACK className:nameBand RBRACK
                    {: return popNativeNewArrayDeclare(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %sym.line%, %sym.column%); :}

                    //nativeMethodExpr
                    |NATIVE:sym classPureName:nameBand DOT IDENTIFIER:ident LPAREN classNameList:list RPAREN
                    {: return popNativeMethodDeclare(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %ident%, %list%, %sym.line%, %sym.column%); :}

                    //nativeConstructorExpr
                    |NATIVE:sym NEW classPureName:nameBand LPAREN classNameList:list RPAREN
                    {: return popNativeConstructorDeclare(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %list%, %sym.line%, %sym.column%); :}

                    |contextValueExpr:expr    {: return %expr%; :}
                    |mapValue:expr    {: return %expr%; :}
                    ;



// super
superCount          ::= SUPER DOT
                        {: return 1; :}
                        |superCount:count SUPER DOT
                        {: return %count% + 1; :}
                        ;


// ident  super...ident  this.ident
contextValueIdent   ::= IDENTIFIER:ident
                        {: return %ident%; :}
                        |FOR DOT IDENTIFIER:ident
                        {: return ("for." + %ident%).intern(); :}
                        ;


contextValueExpr    ::= contextValueIdent:ident
                        {: return createContextValue(0, %ident%, %ident.line%, %ident.column%); :}
                        |THIS DOT contextValueIdent:ident
                        {: return createContextValueAtUpstair(0, %ident%, %ident.line%, %ident.column%); :}
                        |superCount:count contextValueIdent:ident
                        {: return createContextValue(%count%, %ident%, %ident.line%, %ident.column%); :}
                        |superCount:count THIS DOT contextValueIdent:ident
                        {: return createContextValueAtUpstair(%count%, %ident%, %ident.line%, %ident.column%); :}
                        ;


expressionList1     ::= expression:expr
                        {: return new ExpressionList().add(%expr%); :}
                        |expressionList1:list COMMA expression:expr
                        {: return (%list%).add(%expr%); :}
                        ;

expressionList      ::=
                        {: return new ExpressionList(); :}
                        |expressionList1:list
                        {: return %list%; :}
                        ;


// map {key:expr, ...}

mapValuePart         ::= DIRECT_VALUE:key COLON expression:expr
                        {: return new MapValuePart().add(%key%, %expr%); :}
                        |mapValuePart:part COMMA DIRECT_VALUE:key COLON expression:expr
                        {: return (%part%).add(%key%, %expr%); :}
                        ;


mapValue            ::= LBRACE:sym mapValuePart:part RBRACE
                        {: return (%part%).pop(%sym.line%, %sym.column%); :}
                        |LBRACE:sym RBRACE
                        {: return new MapValue(new Object[0], new Expression[0], %sym.line%,%sym.column%); :}
                        ;

/* function  */


funcHead           ::= funcHeadPrepare:part IDENTIFIER:ident
                        {: return (%part%).appendArgIndexs(varmgr.assignVariant(%ident%, %ident.line%, %ident.column%)); :}
                        |funcHead:part COMMA IDENTIFIER:ident
                        {: return (%part%).appendArgIndexs(varmgr.assignVariant(%ident%, %ident.line%, %ident.column%)); :}
                        ;


funcHeadPrepare     ::= FUNCTION:sym LPAREN
                        {: varmgr.push(); varmgr.pushVarWall(); return new FunctionPart(varmgr.assignVariant("arguments", %sym.line%,%sym.column%), %sym.line%,%sym.column%); :}
                        ;


funcExecuteExpr     ::= expression:funcExpr LPAREN expressionList:list RPAREN
                        {: return new FunctionExecuteExpression(%funcExpr%, (%list%).toArray(), %funcExpr.line%, %funcExpr.column%); :}
                        |expression:param0 AT contextValueExpr:funcExpr LPAREN expressionList:list RPAREN
                        {: return new FunctionExecuteExpression(%funcExpr%, (%list%).addFirst(%param0%).toArray(), %funcExpr.line%, %funcExpr.column%); :}
                        ;


classNameList1      ::= className:nameBand
                        {: return new ClassNameList(this.nativeImportMgr).add(%nameBand%, %nameBand.line%, %nameBand.column%); :}
                        |classNameList1:list COMMA className:nameBand
                        {: return (%list%).add(%nameBand%, %nameBand.line%, %nameBand.column%); :}
                        ;

classNameList       ::= 
                        {: return new ClassNameList(this.nativeImportMgr); :}
                        |classNameList1:list
                        {: return %list%; :}
                        ;

