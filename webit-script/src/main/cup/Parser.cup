// Copyright (c) 2013, Webit Team. All Rights Reserved.

package webit.script.core;

import java.lang.reflect.Field;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.operators.*;
import webit.script.core.ast.statements.*;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.ClassUtil;
import webit.script.util.StatementUtil;
import webit.script.util.StringUtil;
import webit.script.util.collection.Stack;


parser code {:

    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }

    private Expression createContextValue(VarAddress addr, int line, int column) {
        switch (addr.type) {
            case VarAddress.ROOT:
                return new RootContextValue(addr.index, line, column);
            case VarAddress.GLOBAL:
                return new GlobalValue(this.engine.getGlobalManager(), addr.index, line, column);
            case VarAddress.CONST:
                return new DirectValue(addr.constValue, line, column);
            default: //VarAddress.CONTEXT
                if (addr.upstairs == 0) {
                    return new CurrentContextValue(addr.index, line, column);
                } else {
                    return new ContextValue(addr.upstairs, addr.index, line, column);
                }
        }
    }
    
    private Expression createContextValueAtUpstair(int upstair, String name, int line, int column) {
        return createContextValue(varmgr.locateAtUpstair(name, upstair, line, column), line, column);
    }
    
    private Expression createContextValue(int upstair, String name, int line, int column) {
        return createContextValue(varmgr.locate(name, upstair, this.locateVarForce, line, column), line, column);
    }

    private Expression createNativeStaticValue(ClassNameBand classNameBand, int line, int column) {
        if (classNameBand.size() < 2) {
            throw new ParseException("native static need a filed name.", line, column);
        }
        final String fieldName = classNameBand.pop();
        final Class clazz = nativeImportMgr.toClass(classNameBand, line, column);
        final String path;
        if (this.engine.getNativeSecurityManager().access(path = (StringUtil.concat(clazz.getName(), ".", fieldName))) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }
        final Field field;
        try {
            field = clazz.getField(fieldName);
        } catch (NoSuchFieldException ex) {
            throw new ParseException("No such field: ".concat(path), line, column);
        }
        if (ClassUtil.isStatic(field)) {
            ClassUtil.setAccessible(field);
            if (ClassUtil.isFinal(field)) {
                try {
                    return new DirectValue(field.get(null), line, column);
                } catch (Exception ex) {
                    throw new ParseException("Failed to static field value: ".concat(path), ex, line, column);
                }
            } else {
                return new NativeStaticValue(field, line, column);
            }
        } else {
            throw new ParseException("No a static field: ".concat(path), line, column);
        }
    }
    
    public CommonMethodDeclareExpression createNativeNewArrayDeclareExpression(Class componentType, int line, int column) {
        return new CommonMethodDeclareExpression(this.nativeFactory.createNativeNewArrayMethodDeclare(componentType, line, column), line, column);
    }
    
    public CommonMethodDeclareExpression createNativeMethodDeclareExpression(Class clazz, String methodName, ClassNameList list, int line, int column) {
        return new CommonMethodDeclareExpression(this.nativeFactory.createNativeMethodDeclare(clazz, methodName, list.toArray(), line, column), line, column);
    }

    public CommonMethodDeclareExpression createNativeConstructorDeclareExpression(Class clazz, ClassNameList list, int line, int column) {
        return new CommonMethodDeclareExpression(this.nativeFactory.createNativeConstructorDeclare(clazz, list.toArray(), line, column), line, column);
    }

    private static ResetableValueExpression castToResetableValueExpression(Expression expr) {
        if(expr instanceof ResetableValueExpression){
            return (ResetableValueExpression) expr;
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", expr);
        }
    }

    private static Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){
        ResetableValueExpression leftExpr = castToResetableValueExpression(lexpr);
        SelfOperator oper;
        switch (sym) {

            // (+ - * / %)=
            case Operators.PLUSEQ:
                oper = new SelfPlus(leftExpr, rightExpr, line, column);
                break;
            case Operators.MINUSEQ:
                oper = new SelfMinus(leftExpr, rightExpr, line, column);
                break;
            case Operators.MULTEQ:
                oper = new SelfMult(leftExpr, rightExpr, line, column);
                break;
            case Operators.DIVEQ:
                oper = new SelfDiv(leftExpr, rightExpr, line, column);
                break;
            case Operators.MODEQ:
                oper = new SelfMod(leftExpr, rightExpr, line, column);
                break;

            // (<< >> >>>)=
            case Operators.LSHIFTEQ:
                oper = new SelfLShift(leftExpr, rightExpr, line, column);
                break;
            case Operators.RSHIFTEQ:
                oper = new SelfRShift(leftExpr, rightExpr, line, column);
                break;
            case Operators.URSHIFTEQ:
                oper = new SelfURShift(leftExpr, rightExpr, line, column);
                break;

            // (& ^ |)=
            case Operators.ANDEQ:
                oper = new SelfBitAnd(leftExpr, rightExpr, line, column);
                break;
            case Operators.XOREQ:
                oper = new SelfBitXor(leftExpr, rightExpr, line, column);
                break;
            case Operators.OREQ:
                oper = new SelfBitOr(leftExpr, rightExpr, line, column);
                break;

            default:
                throw new ParseException("Unsupported Operator", line, column);
        }

        return StatementUtil.optimize(oper);
    }

    private static Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new And(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAnd(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOr(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXor(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new Div(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new Equals(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEquals(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new Greater(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShift(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEquals(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new Less(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new Minus(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new Mod(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new Mult(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEquals(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new Or(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new Plus(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShift(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShift(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStep(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatementUtil.optimize(oper);
    }

:};


/* Terminals */
terminal Integer    VAR,
                    IF, ELSE,
                    FOR, /* IN, */
                    THIS, SUPER,
                    SWITCH, CASE, DEFAULT,
                    DO, WHILE,
                    THROW, TRY, CATCH, FINALLY,
                    NEW,
                    INSTANCEOF,
                    FUNCTION,
                    ECHO,
                    STATIC, NATIVE,
                    IMPORT, INCLUDE, NATIVE_IMPORT,
                    BREAK, CONTINUE, RETURN,

                    PLUSPLUS, MINUSMINUS,  // ++ ==
                    PLUS, MINUS, MULT, DIV, MOD,  // + - * /
                    LSHIFT, RSHIFT, URSHIFT,  // << >> >>>
                    LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ,  // < > <= >= == !=
                    AND, XOR, OR, COMP,  // & ^ | ~
                    ANDAND, OROR, NOT,  // && || !
                    QUESTION, QUESTION_COLON,// ?  ?:
                    SELFEQ,  // (+ - * / %)= (<< >> >>>)= (& ^ |)=
                    UMINUS,
                    DOT,  // .
                    COLON,  // :
                    COMMA,  // ,
                    SEMICOLON,  // ;
                    LBRACE, RBRACE, PLACE_HOLDER_END, // { }
                    LPAREN, RPAREN,  // ( )
                    LBRACK, RBRACK,  // [ ]
                    EQGT,  // =>
                    AT,  // @
                    DOTDOT,  // ..
                    EQ   // =
                    ;


terminal String     IDENTIFIER; // Ident
terminal char[]     TEXT_STATEMENT;
terminal Object     DIRECT_VALUE;



/* non terminal */
non terminal ClassNameBand classPureName, className;

/* TemplateAST */
non terminal TemplateAST templateAST;

/* Statement */
non terminal StatementList statementList;

non terminal Statement statement, ifStat;
non terminal IBlock block, caseBlockStat;
non terminal StatementList varPart;
non terminal Expression varAssign;
non terminal ImportPart importPart1, importPart2;
non terminal Object blockPrepare, blockPrepare2;
non terminal SwitchPart switchPart, switchPart0;
non terminal AbstractForInPart forInHead, forInBody, forInPart;
non terminal WhilePart whilePart;
non terminal IfPart ifPart;

/* Expression */
non terminal Expression expression, expression_statementable;
non terminal ExpressionList expressionList, expressionList1;
non terminal MapValuePart mapValuePart;
non terminal MapValue mapValue;

non terminal String contextValueIdent;
non terminal Integer superCount;
non terminal Expression contextValueExpr;
non terminal ClassNameList classNameList, classNameList1;

/* function */
non terminal Expression funcExecuteExpr;
non terminal FunctionDeclarePart funcHeadPrepare, funcHead;


/* precedence */
precedence left     SEMICOLON; // ;
precedence right    SELFEQ, EQ; // (+ - * / %)=  (<< >> >>>)=  (& ^ |)=  = 
precedence left     DOTDOT;  // ..
precedence right    QUESTION, QUESTION_COLON; // [? : ] ?:
precedence left     OROR; // ||
precedence left     ANDAND; // &&
precedence left     XOR; // ^
precedence left     OR; // |
precedence left     AND; // &
precedence left     EQEQ, NOTEQ; // == !=
precedence left     LT, LTEQ, GT, GTEQ; // < <= > >=  //Unsupport: instanceOf
precedence left     LSHIFT, RSHIFT, URSHIFT; // << >> >>>
precedence left     PLUS, MINUS; // + -
precedence left     MULT, DIV, MOD; // * / %
precedence right    PLUSPLUS, MINUSMINUS, UMINUS, NOT, COMP; // ++ -- - ! ~
precedence left     EQGT;  // =>
precedence left     DOT, LBRACK, LPAREN, LBRACE, AT; // . [ ( { @



/* templateAST */

templateAST            ::= statementList:list
                        {: return (%list%).popTemplateAST(varmgr.pop()); :}
                        ;

statementList           ::= 
                        {: return new StatementList(); :}
                        |statementList:list statement:stat
                        {: return (%list%).add(%stat%); :}
                        ;


classPureName       ::= IDENTIFIER:ident
                        {: return new ClassNameBand(%ident%); :}
                        |classPureName:part DOT IDENTIFIER:ident
                        {: return (%part%).append(%ident%); :}
                        ;

className           ::= classPureName:part
                        {: return %part%; :}
                        |className:part LBRACK RBRACK
                        {: return (%part%).plusArrayDepth(); :}
                        ;


/* statements  */
statement            ::= expression_statementable:expr SEMICOLON
                        {: return %expr%; :}

                        |SEMICOLON
                        {: return NoneStatement.getInstance(); :}

                        |expression:expr PLACE_HOLDER_END
                        {: return placeHolderFactory.creatPlaceHolder(%expr%); :}

                        |block:stat
                        {: return %stat%; :}

                        |ifStat:stat
                        {: return %stat%; :}

                        //switch
                        |switchPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON switchPart:part
                        {: return (%part%).pop(getLabelIndex(%label%)); :}
                        
                        //while
                        |whilePart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON whilePart:part
                        {: return (%part%).pop(getLabelIndex(%label%)); :}

                        //forIn
                        |forInPart:part
                        {: return (%part%).pop(); :}
                        |IDENTIFIER:label COLON forInPart:part
                        {: return (%part%).pop(getLabelIndex(%label%)); :}

                        //RedirectOut
                        |block:stat EQGT:sym expression:expr SEMICOLON
                        {: return new RedirectOut(%stat%, castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                        //textStat
                        |TEXT_STATEMENT:sym
                        {: return textStatementFactory.getTextStatement(template, %sym%, %sym.line%, %sym.column%); :}

                        //var
                        |varPart:part SEMICOLON
                        {: return (%part%).popStatementGroup(%part.line%, %part.column%); :}

                        //echoStat
                        |ECHO:sym expression:expr SEMICOLON
                        {: return new Echo(%expr%, %sym.line%, %sym.column%); :}

                        //@import
                        |NATIVE_IMPORT:sym classPureName:nameBand SEMICOLON
                        {: nativeImportMgr.registClass(%nameBand%, %sym.line%, %sym.column%); return NoneStatement.getInstance(); :}
                        
                        //BREAK
                        |BREAK:sym SEMICOLON
                        {: return new Break(0, %sym.line%, %sym.column%); :}
                        |BREAK:sym IDENTIFIER:label SEMICOLON
                        {: return new Break(getLabelIndex(%label%), %sym.line%, %sym.column%); :}
                        
                        //CONTINUE
                        |CONTINUE:sym SEMICOLON
                        {: return new Continue(0, %sym.line%, %sym.column%); :}
                        |CONTINUE:sym IDENTIFIER:label SEMICOLON
                        {: return new Continue(getLabelIndex(%label%), %sym.line%, %sym.column%); :}
                        
                        //RETURN
                        |RETURN:sym SEMICOLON
                        {: return new Return(null, %sym.line%, %sym.column%); :}
                        |RETURN:sym expression:expr SEMICOLON
                        {: return new Return(%expr%, %sym.line%, %sym.column%); :}

                        //importStat
                        |importPart1:part SEMICOLON
                        {: return (%part%).pop(this.template); :}
                        |importPart2:part SEMICOLON
                        {: return (%part%).pop(this.template); :}

                        //includeStat
                        |INCLUDE:sym expression:expr SEMICOLON
                        {: return new Include(%expr%, null, this.template, %sym.line%, %sym.column%); :}
                        |INCLUDE:sym expression:expr mapValue:paramsExpr SEMICOLON
                        {: return new Include(%expr%, %paramsExpr%, this.template, %sym.line%, %sym.column%); :}
                        |INCLUDE:sym expression:expr LBRACE expression:paramsExpr RBRACE SEMICOLON
                        {: return new Include(%expr%, %paramsExpr%, this.template, %sym.line%, %sym.column%); :}
                        ;

varAssign       ::= IDENTIFIER:ident EQ:sym expression:expr
                    {: return new Assign(castToResetableValueExpression(createContextValue(varmgr.assignVariantAddress(%ident%,%ident.line%,%ident.column%), %ident.line%, %ident.column%)), %expr%, %sym.line%, %sym.column%); :}
                    | IDENTIFIER:ident EQ:sym varAssign:expr
                    {: return new Assign(castToResetableValueExpression(createContextValue(varmgr.assignVariantAddress(%ident%,%ident.line%,%ident.column%), %ident.line%, %ident.column%)), %expr%, %sym.line%, %sym.column%); :}
                    ;

varPart         ::= VAR IDENTIFIER:ident
                    {: varmgr.assignVariant(%ident%,%ident.line%,%ident.column%); return new StatementList();:}
                    | VAR varAssign:expr
                    {: return new StatementList().add(%expr%); :}
                    | varPart:part COMMA IDENTIFIER:ident
                    {: varmgr.assignVariant(%ident%,%ident.line%,%ident.column%); return %part%;:}
                    | varPart:part COMMA varAssign:expr
                    {: return (%part%).add(%expr%); :}
                    ;


importPart1     ::= IMPORT:sym expression:expr
                        {: return new ImportPart(%expr%, %sym.line%, %sym.column%); :}
                        |IMPORT:sym expression:expr mapValue:paramsExpr
                        {: return new ImportPart(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        |IMPORT:sym expression:expr LBRACE expression:paramsExpr RBRACE
                        {: return new ImportPart(%expr%, %paramsExpr%, %sym.line%, %sym.column%); :}
                        ;


importPart2     ::= importPart1:part IDENTIFIER:ident
                        {: return (%part%).append(%ident%, createContextValue(0, %ident%, %ident.line%, %ident.column%)); :}
                        |importPart1:part contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: return (%part%).append(%ident%, %valueExpr%); :}
                        |importPart2:part COMMA IDENTIFIER:ident
                        {: return (%part%).append(%ident%, createContextValue(0, %ident%, %ident.line%, %ident.column%)); :}
                        |importPart2:part COMMA contextValueExpr:valueExpr EQ IDENTIFIER:ident
                        {: return (%part%).append(%ident%, %valueExpr%); :}
                        ;


blockPrepare    ::= 
                        {: varmgr.push(); return null; :}
                        ;
blockPrepare2   ::= LBRACE
                        {: varmgr.push(); return null; :}
                        ;


block           ::= blockPrepare2:prepare statementList:list RBRACE
                        {: return (%list%).popIBlock(varmgr.pop(), %prepare.line%, %prepare.column%); :}
                        ;


ifPart      ::= IF:sym LPAREN expression:expr RPAREN block:body
                        {: return new IfPart(%expr%, %body%, %sym.line%, %sym.column%); :}
                        ;


ifStat          ::= ifPart:part
                        {: return (%part%).pop(); :}
                        |ifPart:part ELSE block:elseBody
                        {: return (%part%).pop(%elseBody%); :}
                        |ifPart:part ELSE ifStat:elseBody
                        {: return (%part%).pop(%elseBody%); :}
                        ;


forInHead       ::= FOR:sym LPAREN IDENTIFIER:item COLON expression:items RPAREN
                        {: return new ForInPart(%item%, %items%, this.varmgr, %sym.line%, %sym.column%); :}
                        |FOR:sym LPAREN IDENTIFIER:key COMMA IDENTIFIER:value COLON expression:map RPAREN
                        {: return new ForMapPart(%key%, %value%, %map%, this.varmgr, %sym.line%, %sym.column%); :}
                        ;


forInBody       ::= forInHead:part LBRACE statementList:list RBRACE
                        {: return (%part%).setStatementList(%list%); :}
                        ;


forInPart       ::= forInBody:part
                        {: return %part%; :}
                        |forInBody:part ELSE block:elseBody
                        {: return (%part%).setElse(%elseBody%); :}
                        ;


whilePart       ::= WHILE:sym LPAREN expression:whileExpr RPAREN block:body
                        {: return new WhilePart(%whileExpr%, %body%, true, %sym.line%, %sym.column%); :}
                        |DO:sym block:body WHILE LPAREN expression:whileExpr RPAREN SEMICOLON
                        {: return new WhilePart(%whileExpr%, %body%, false, %sym.line%, %sym.column%); :}
                        ;


caseBlockStat       ::= blockPrepare:prepare statementList:list
                        {: return (%list%).popIBlock(varmgr.pop(), %prepare.line%, %prepare.column%); :}
                        ;


switchPart0         ::= 
                        {: return new SwitchPart(); :}
                        | CASE:sym DIRECT_VALUE:key COLON caseBlockStat:body switchPart0:part
                        {: return (%part%).appendCase(%key%, %body%, %sym.line%, %sym.column%); :}
                        | DEFAULT:sym COLON caseBlockStat:body switchPart0:part
                        {: return (%part%).appendCase(null, %body%, %sym.line%, %sym.column%); :}
                        ;


switchPart          ::= SWITCH:sym LPAREN expression:switchExpr RPAREN LBRACE switchPart0:part RBRACE
                        {: return (%part%).setSwitchExpr(%switchExpr%, %sym.line%, %sym.column%); :}
                        ;



/* Expressions */

expression_statementable ::= 
                    //assignOper = 
                    expression:lexpr EQ:sym expression:expr
                    {: return new Assign(castToResetableValueExpression(%lexpr%), %expr%, %sym.line%, %sym.column%); :}

                    //plusPlusOper ++
                    |PLUSPLUS:sym expression:expr
                    {: return new PlusPlusBefore(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}
                    |expression:expr PLUSPLUS:sym
                    {: return new PlusPlusAfter(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                    //minusMinusOper --
                    |MINUSMINUS:sym expression:expr
                    {: return new MinusMinusBefore(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}
                    |expression:expr MINUSMINUS:sym
                    {: return new MinusMinusAfter(castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                    //selfOper
                    |expression:lexpr SELFEQ:sym expression:rexpr
                    {: return createSelfOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    
                    //RedirectOutExpression =>
                    |funcExecuteExpr:srcExpr EQGT:sym expression:expr
                    {: return new RedirectOutExpression(%srcExpr%, castToResetableValueExpression(%expr%), %sym.line%, %sym.column%); :}

                    //
                    |funcExecuteExpr:expr    {: return %expr%; :}
                    ;


expression      ::= expression_statementable:expr
                    {: return %expr%; :}

                    //bitNotOper ~
                    |COMP:sym expression:expr
                    {: return StatementUtil.optimize(new BitNot(%expr%, %sym.line%, %sym.column%)); :}
                    
                    //negativeOper  -
                    |MINUS:sym expression:expr
                    {: return StatementUtil.optimize(new Negative(%expr%, %sym.line%, %sym.column%)); :}
                    %prec UMINUS
                    
                    //notOper !
                    |NOT:sym expression:expr
                    {: return StatementUtil.optimize(new Not(%expr%, %sym.line%, %sym.column%)); :}

                    //propertyOper .
                    |expression:expr DOT:sym IDENTIFIER:ident 
                    {: return new PropertyOperator(%expr%, %ident%, %sym.line%, %sym.column%); :}
                    
                    //indexOper []
                    |expression:lexpr LBRACK:sym expression:rexpr RBRACK
                    {: return new IndexOperator(%lexpr%, %rexpr%, %sym.line%, %sym.column%); :}

                    /***********  binarys *************/
                    //-- binary:  *
                    |expression:lexpr MULT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  /
                    |expression:lexpr DIV:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  %
                    |expression:lexpr MOD:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  +
                    |expression:lexpr PLUS:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  -
                    |expression:lexpr MINUS:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <<
                    |expression:lexpr LSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >>
                    |expression:lexpr RSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >>>
                    |expression:lexpr URSHIFT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <
                    |expression:lexpr LT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  <=
                    |expression:lexpr LTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >
                    |expression:lexpr GT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  >=
                    |expression:lexpr GTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ==
                    |expression:lexpr EQEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  !=
                    |expression:lexpr NOTEQ:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  &
                    |expression:lexpr AND:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  |
                    |expression:lexpr OR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ^
                    |expression:lexpr XOR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  &&
                    |expression:lexpr ANDAND:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ..
                    |expression:lexpr DOTDOT:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ||
                    |expression:lexpr OROR:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}
                    //-- binary:  ?:
                    |expression:lexpr QUESTION_COLON:sym expression:rexpr
                    {: return createBinaryOperator(%lexpr%, %sym%, %rexpr%, %sym.line%, %sym.column%); :}

                    //ifOper ? :
                    |expression:ifexpr QUESTION:sym expression:lexpr COLON expression:rexpr
                    {: return new IfOperator(%ifexpr%, %lexpr%, %rexpr%, %sym.line%, %sym.column%); :}

                    //
                    |DIRECT_VALUE:sym
                    {: return new DirectValue(%sym%, %sym.line%, %sym.column%); :}
                    
                    // ()
                    |LPAREN expression:expr RPAREN
                    {: return %expr%; :}

                    //funcDeclareExpr
                    |funcHeadPrepare:part LPAREN RPAREN LBRACE statementList:list RBRACE
                    {: return (%part%).pop(varmgr, %list%); :}
                    |funcHeadPrepare:part LBRACE statementList:list RBRACE
                    {: return (%part%).pop(varmgr, %list%); :}
                    |funcHead:part RPAREN LBRACE statementList:list RBRACE
                    {: return (%part%).pop(varmgr, %list%); :}


                    //arrayValue
                    |LBRACK:sym expressionList:list RBRACK
                    {: return new ArrayValue((%list%).toArray(), %sym.line%, %sym.column%); :}


                    //NativeNewArrayDeclareExpression 
                    |NATIVE:sym LBRACK RBRACK className:nameBand
                    {: return this.createNativeNewArrayDeclareExpression(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %sym.line%, %sym.column%); :}
                    |NATIVE:sym LBRACK className:nameBand RBRACK
                    {: return this.createNativeNewArrayDeclareExpression(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %sym.line%, %sym.column%); :}

                    //nativeMethodExpr
                    |NATIVE:sym classPureName:nameBand DOT IDENTIFIER:ident LPAREN classNameList:list RPAREN
                    {: return this.createNativeMethodDeclareExpression(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %ident%, %list%, %sym.line%, %sym.column%); :}

                    //native static field
                    |NATIVE classPureName:nameBand
                    {: return createNativeStaticValue(%nameBand%, %nameBand.line%, %nameBand.column%); :}

                    //nativeConstructorExpr
                    |NATIVE:sym NEW classPureName:nameBand LPAREN classNameList:list RPAREN
                    {: return this.createNativeConstructorDeclareExpression(nativeImportMgr.toClass(%nameBand%, %nameBand.line%, %nameBand.column%), %list%, %sym.line%, %sym.column%); :}

                    |contextValueExpr:expr    {: return %expr%; :}
                    |mapValue:expr    {: return %expr%; :}
                    ;



// super
superCount          ::= SUPER DOT
                        {: return 1; :}
                        |superCount:count SUPER DOT
                        {: return %count% + 1; :}
                        ;


// ident  super...ident  this.ident
contextValueIdent   ::= IDENTIFIER:ident
                        {: return %ident%; :}
                        |FOR DOT IDENTIFIER:ident
                        {: return ("for." + %ident%).intern(); :}
                        ;


contextValueExpr    ::= contextValueIdent:ident
                        {: return createContextValue(0, %ident%, %ident.line%, %ident.column%); :}
                        |THIS DOT contextValueIdent:ident
                        {: return createContextValueAtUpstair(0, %ident%, %ident.line%, %ident.column%); :}
                        |superCount:count contextValueIdent:ident
                        {: return createContextValue(%count%, %ident%, %ident.line%, %ident.column%); :}
                        |superCount:count THIS DOT contextValueIdent:ident
                        {: return createContextValueAtUpstair(%count%, %ident%, %ident.line%, %ident.column%); :}
                        ;


expressionList1     ::= expression:expr
                        {: return new ExpressionList().add(%expr%); :}
                        |expressionList1:list COMMA expression:expr
                        {: return (%list%).add(%expr%); :}
                        ;

expressionList      ::=
                        {: return new ExpressionList(); :}
                        |expressionList1:list
                        {: return %list%; :}
                        ;


// map {key:expr, ...}

mapValuePart         ::= DIRECT_VALUE:key COLON expression:expr
                        {: return new MapValuePart().add(%key%, %expr%); :}
                        |mapValuePart:part COMMA DIRECT_VALUE:key COLON expression:expr
                        {: return (%part%).add(%key%, %expr%); :}
                        ;


mapValue            ::= LBRACE:sym mapValuePart:part RBRACE
                        {: return (%part%).pop(%sym.line%, %sym.column%); :}
                        |LBRACE:sym RBRACE
                        {: return new MapValue(new Object[0], new Expression[0], %sym.line%,%sym.column%); :}
                        ;

/* function  */


funcHead           ::= funcHeadPrepare:part LPAREN IDENTIFIER:ident
                        {: return (%part%).appendArg(%ident%, %ident.line%, %ident.column%); :}
                        |funcHead:part COMMA IDENTIFIER:ident
                        {: return (%part%).appendArg(%ident%, %ident.line%, %ident.column%); :}
                        ;


funcHeadPrepare     ::= FUNCTION:sym
                        {: return new FunctionDeclarePart(this.varmgr, %sym.line%, %sym.column%); :}
                        ;


funcExecuteExpr     ::= expression:funcExpr LPAREN expressionList:list RPAREN
                        {: return new FunctionExecute(%funcExpr%, (%list%).toArray(), %funcExpr.line%, %funcExpr.column%); :}
                        |expression:param0 AT contextValueExpr:funcExpr LPAREN expressionList:list RPAREN
                        {: return new FunctionExecute(%funcExpr%, (%list%).addFirst(%param0%).toArray(), %funcExpr.line%, %funcExpr.column%); :}
                        ;


classNameList1      ::= className:nameBand
                        {: return new ClassNameList(this.nativeImportMgr).add(%nameBand%, %nameBand.line%, %nameBand.column%); :}
                        |classNameList1:list COMMA className:nameBand
                        {: return (%list%).add(%nameBand%, %nameBand.line%, %nameBand.column%); :}
                        ;

classNameList       ::= 
                        {: return new ClassNameList(this.nativeImportMgr); :}
                        |classNameList1:list
                        {: return %list%; :}
                        ;

