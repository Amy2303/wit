
//----------------------------------------------------
// The following code was generated by CUP v0.12for-WebitScript-only
// Tue Oct 22 12:39:14 CST 2013
//----------------------------------------------------

package webit.script.core;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import webit.script.asm.AsmMethodCaller;
import webit.script.asm.AsmMethodCallerManager;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.method.*;
import webit.script.core.ast.statments.*;
import webit.script.core.java_cup.runtime.Stack;
import webit.script.core.java_cup.runtime.Symbol;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.ClassUtil;
import webit.script.util.StatmentUtil;
import webit.script.util.StringUtil;

/** CUP v0.12for-WebitScript-only generated parser.
  * @version Tue Oct 22 12:39:14 CST 2013
  */
public class Parser extends webit.script.core.java_cup.runtime.lr_parser {



  /** Production table. */
  private static final short PRODUCTION_TABLE[][] = loadFromDataFile("Production");

  /** Parse-action table. */
  private static final short[][] ACTION_TABLE = loadFromDataFile("Action");

  /** <code>reduce_goto</code> table. */
  private static final short[][] REDUCE_TABLE = loadFromDataFile("Reduce");
  /** Indicates start state. */
  private final static int START_STATE = 0;


    public Parser() {
        super(START_STATE, PRODUCTION_TABLE, ACTION_TABLE, REDUCE_TABLE);
        nativeImportMgr = new NativeImportManager();
        varmgr = new VariantManager();
        labelsIndexMap = new HashMap<String, Integer>();
        labelsIndexMap.put(null, 0);
    }
    
    private Stack<Symbol> getStack() {
        return this._stack;
    }

    private final NativeImportManager nativeImportMgr;
    private final VariantManager varmgr;
    private final Map<String, Integer> labelsIndexMap;

    private int currentLabelIndex = 0;
    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }

    private ForInStatmentPart createForInStatmentPart(String item, Expression items, int line, int column){
        try {
            int itemIndex = varmgr.assignVariantForNextBlock(item);
            int iterIndex = varmgr.assignVariantForNextBlock("for.iter");

            return new ForInStatmentPart(itemIndex, iterIndex, items, line, column);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private ForMapStatmentPart createForMapStatmentPart(String key, String value, Expression map, int line, int column){
        try {
            int keyIndex = varmgr.assignVariantForNextBlock(key);
            int valueIndex = varmgr.assignVariantForNextBlock(value);
            int iterIndex = varmgr.assignVariantForNextBlock("for.iter");

            return new ForMapStatmentPart(keyIndex, valueIndex, iterIndex, map, line, column);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private ResetableValueExpression createContextValue(String name, int line, int column) {
        VarAddress addr;
        return (addr = varmgr.locate(name, this.locateVarForce, line, column)).upstairs == 0
                ? new CurrentContextValue(addr.index, name, line, column)
                : new ContextValue(addr.upstairs, addr.index, name, line, column);
    }

    private ResetableValueExpression createContextValue(int upstair, String name, int line, int column) {
        int index = varmgr.locateAtUpstair(name, upstair, true, line, column);
        return upstair == 0
                ? new CurrentContextValue(index, name, line, column)
                : new ContextValue(upstair, index, name, true, line, column);
    }

    public CommonMethodDeclareExpression popNativeNewArrayDeclare(Class componentType, int line, int column) {
        Class classWaitCheck = componentType;
        while (classWaitCheck.isArray()) {
            classWaitCheck = classWaitCheck.getComponentType();
        }

        if (classWaitCheck == Void.class || classWaitCheck == Void.TYPE) {
            throw new ParseException("ComponentType must not Void.class", line, column);
        }

        final String path;
        if (engine.checkNativeAccess(path = (classWaitCheck.getName().concat(".[]"))) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }

        return new CommonMethodDeclareExpression(new NativeNewArrayDeclare(componentType), line, column);
    }

    public CommonMethodDeclareExpression popNativeMethodDeclare(Class clazz, String methodName, ClassNameList list, int line, int column) {

        final String path;
        if (engine.checkNativeAccess(path = (StringUtil.concat(clazz.getName(), ".", methodName))) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }

        try {
            final Method method = ClassUtil.searchMethod(clazz, methodName, list.toArray(), false);
            AsmMethodCaller caller;
            if (engine.isEnableAsmNative()) {
                if (ClassUtil.isPublic(clazz)) {
                    if (ClassUtil.isPublic(method)) {
                        try {
                            if ((caller = AsmMethodCallerManager.getCaller(method)) == null) {
                                logger.error(StringUtil.concat("AsmMethodCaller for '", method.toString(), "' is null, and instead by NativeMethodDeclare"));
                            }
                        } catch (Exception ex) {
                            caller = null;
                            logger.error(StringUtil.concat("Generate AsmMethodCaller for '", method.toString(), "' failed, and instead by NativeMethodDeclare"), ex);
                        }
                    } else {
                        logger.warn(StringUtil.concat("'", method.toString(), "' will not use asm, since this method is not public, and instead by NativeMethodDeclare"));
                        caller = null;
                    }
                } else {
                    logger.warn(StringUtil.concat("'", method.toString(), "' will not use asm, since class is not public, and instead by NativeMethodDeclare"));
                    caller = null;
                }
            } else {
                caller = null;
            }

            return new CommonMethodDeclareExpression(caller != null
                    ? new AsmNativeMethodDeclare(caller)
                    : new NativeMethodDeclare(method),
                    line, column);

        } catch (NoSuchMethodException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        } catch (SecurityException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        }
    }

    @SuppressWarnings("unchecked")
    public CommonMethodDeclareExpression popNativeConstructorDeclare(Class clazz, ClassNameList list, int line, int column) {

        final String path;
        if (engine.checkNativeAccess(path = (clazz.getName() + ".<init>")) == false) {
            throw new ParseException("Not accessable of native path: ".concat(path), line, column);
        }

        try {
            final Constructor constructor = clazz.getConstructor(list.toArray());
            AsmMethodCaller caller;
            if (engine.isEnableAsmNative()) {
                if (ClassUtil.isPublic(clazz)) {
                    if (ClassUtil.isPublic(constructor)) {
                        try {
                            if ((caller = AsmMethodCallerManager.getCaller(constructor)) == null) {
                                logger.error(StringUtil.concat("AsmMethodCaller for '", constructor.toString(), "' is null, and instead by NativeConstructorDeclare"));
                            }
                        } catch (Exception ex) {
                            caller = null;
                            logger.error(StringUtil.concat("Generate AsmMethodCaller for '", constructor.toString(), "' failed, and instead by NativeConstructorDeclare"), ex);
                        }
                    } else {
                        logger.warn(StringUtil.concat("'", constructor.toString(), "' will not use asm, since this method is not public, and instead by NativeConstructorDeclare"));
                        caller = null;
                    }
                } else {
                    logger.warn(StringUtil.concat("'" + constructor.toString() + "' will not use asm, since class is not public, and instead by NativeConstructorDeclare"));
                    caller = null;
                }
            } else {
                caller = null;
            }

            return new CommonMethodDeclareExpression(caller != null
                    ? new AsmNativeMethodDeclare(caller)
                    : new NativeConstructorDeclare(constructor),
                    line, column);

        } catch (NoSuchMethodException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        } catch (SecurityException ex) {
            throw new ParseException(ex.getMessage(), line, column);
        }
    }

    private static ResetableValueExpression castToResetableValueExpression(Expression expr) {
        if(expr instanceof ResetableValueExpression){
            return (ResetableValueExpression) expr;
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", expr);
        }
    }

    private static Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){
        ResetableValueExpression leftExpr = castToResetableValueExpression(lexpr);
        SelfOperator oper;
        switch (sym) {

            // (+ - * / %)=
            case Operators.PLUSEQ:
                oper = new SelfPlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MINUSEQ:
                oper = new SelfMinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MULTEQ:
                oper = new SelfMultOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.DIVEQ:
                oper = new SelfDivOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MODEQ:
                oper = new SelfModOperator(leftExpr, rightExpr, line, column);
                break;

            // (<< >> >>>)=
            case Operators.LSHIFTEQ:
                oper = new SelfLShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.RSHIFTEQ:
                oper = new SelfRShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.URSHIFTEQ:
                oper = new SelfURShiftOperator(leftExpr, rightExpr, line, column);
                break;

            // (& ^ |)=
            case Operators.ANDEQ:
                oper = new SelfBitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.XOREQ:
                oper = new SelfBitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.OREQ:
                oper = new SelfBitOrOperator(leftExpr, rightExpr, line, column);
                break;

            default:
                throw new ParseException("Unsupported Operator", line, column);
        }

        return StatmentUtil.optimize(oper);
    }

    private static Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new AndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new DivOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new EqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new GreaterOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new LessOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new MinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new ModOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new MultOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new OrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new PlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStepOperator(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatmentUtil.optimize(oper);
    }


  protected final Object do_action(int act_id) throws ParseException {
      webit.script.core.java_cup.runtime.Stack<webit.script.core.java_cup.runtime.Symbol> myStack = this.getStack();

      /* select the action based on the action number */
      switch (act_id){
	case 124: // contextValueIdent ::= FOR DOT IDENTIFIER 
	{
		 return ("for." + (String) myStack.peek(0).value).intern(); 
	}

	case 5: // classPureName ::= classPureName DOT IDENTIFIER 
	{
		 return ((ClassNameBand) myStack.peek(2).value).append((String) myStack.peek(0).value); 
	}

	case 7: // className ::= className LBRACK RBRACK 
	{
		 return ((ClassNameBand) myStack.peek(2).value).plusArrayDepth(); 
	}

	case 129: // expressionList1 ::= expressionList1 COMMA expression 
	{
		 return ((ExpressionList) myStack.peek(2).value).add((Expression) myStack.peek(0).value); 
	}

	case 53: // forInStat ::= forInStatPart 
	{
		 return ((ForInStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 51: // forInStatPart1 ::= IDENTIFIER COLON forInStatPart0 
	{
		 return ((ForInStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(2).value)); 
	}

	case 52: // forInStatPart ::= forInStatPart1 blockStat 
	{
		 return ((ForInStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 54: // forInStat ::= forInStatPart ELSE blockStat 
	{
		 return ((ForInStatmentPart) myStack.peek(2).value).setElseStatment((IBlockStatment) myStack.peek(0).value).pop(); 
	}

	case 59: // forMapStat ::= forMapStatPart 
	{
		 return ((ForMapStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 57: // forMapStatPart1 ::= IDENTIFIER COLON forMapStatPart0 
	{
		 return ((ForMapStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(2).value)); 
	}

	case 58: // forMapStatPart ::= forMapStatPart1 blockStat 
	{
		 return ((ForMapStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 60: // forMapStat ::= forMapStatPart ELSE blockStat 
	{
		 return ((ForMapStatmentPart) myStack.peek(2).value).setElseStatment((IBlockStatment) myStack.peek(0).value).pop(); 
	}

	case 112: // expression ::= funcHeadPrepare RPAREN LBRACE statmentList RBRACE 
	case 113: // expression ::= funcHead RPAREN LBRACE statmentList RBRACE 
	{
		 return ((FunctionPart) myStack.peek(4).value).pop(varmgr, (StatmentList) myStack.peek(1).value); 
	}

	case 46: // ifStat ::= ifStatPart 
	{
		 return ((IfStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 47: // ifStat ::= ifStatPart ELSE blockStat 
	{
		 return ((IfStatmentPart) myStack.peek(2).value).setElseStatment((IBlockStatment) myStack.peek(0).value).pop(); 
	}

	case 48: // ifStat ::= ifStatPart ELSE ifStat 
	{
		 return ((IfStatmentPart) myStack.peek(2).value).setElseStatment((Statment) myStack.peek(0).value).pop(); 
	}

	case 28: // statment ::= importStatPart1 SEMICOLON 
	case 29: // statment ::= importStatPart2 SEMICOLON 
	{
		 return ((ImportStatmentPart) myStack.peek(1).value).pop(); 
	}

	case 39: // importStatPart2 ::= importStatPart1 contextValueExpr EQ IDENTIFIER 
	{
		 return ((ImportStatmentPart) myStack.peek(3).value).append((String) myStack.peek(0).value, (ResetableValueExpression) myStack.peek(2).value); 
	}

	case 41: // importStatPart2 ::= importStatPart2 COMMA contextValueExpr EQ IDENTIFIER 
	{
		 return ((ImportStatmentPart) myStack.peek(4).value).append((String) myStack.peek(0).value, (ResetableValueExpression) myStack.peek(2).value); 
	}

	case 133: // mapKeyValue ::= mapKeyValue COMMA DIRECT_VALUE COLON expression 
	{
		 return ((MapKeyValue) myStack.peek(4).value).add((Object) myStack.peek(2).value, (Expression) myStack.peek(0).value); 
	}

	case 0: // templateAST ::= statmentList 
	{
		 return ((StatmentList) myStack.peek(0).value).popTemplateAST(varmgr.pop()); 
	}

	case 3: // statmentList ::= statmentList statment 
	{
		 return ((StatmentList) myStack.peek(1).value).add((Statment) myStack.peek(0).value); 
	}

	case 71: // switchStat ::= switchStatPart 
	{
		 return ((SwitchStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 72: // switchStat ::= IDENTIFIER COLON switchStatPart 
	{
		 return ((SwitchStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(2).value)).pop(); 
	}

	case 64: // whileStat ::= whileStatPart 
	{
		 return ((WhileStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 65: // whileStat ::= IDENTIFIER whileStatPart 
	{
		 return ((WhileStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(1).value)).pop(); 
	}

	case 62: // whileStatPart ::= whileStatPart0 blockStat 
	{
		 return ((WhileStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 6: // className ::= classPureName 
	{
		 return (ClassNameBand) myStack.peek(0).value; 
	}

	case 144: // classNameList ::= classNameList1 
	{
		 return (ClassNameList) myStack.peek(0).value; 
	}

	case 81: // expression_statmentable ::= funcExecuteExpr 
	case 82: // expression ::= expression_statmentable 
	{
		 return (Expression) myStack.peek(0).value; 
	}

	case 8: // statment ::= expression_statmentable SEMICOLON 
	case 111: // expression ::= LPAREN expression RPAREN 
	{
		 return (Expression) myStack.peek(1).value; 
	}

	case 131: // expressionList ::= expressionList1 
	{
		 return (ExpressionList) myStack.peek(0).value; 
	}

	case 50: // forInStatPart1 ::= forInStatPart0 
	{
		 return (ForInStatmentPart) myStack.peek(0).value; 
	}

	case 56: // forMapStatPart1 ::= forMapStatPart0 
	{
		 return (ForMapStatmentPart) myStack.peek(0).value; 
	}

	case 11: // statment ::= blockStat 
	{
		 return (IBlockStatment) myStack.peek(0).value; 
	}

	case 122: // superCount ::= superCount SUPER DOT 
	{
		 return (Integer) myStack.peek(2).value + 1; 
	}

	case 120: // expression ::= mapValue 
	{
		 return (MapValue) myStack.peek(0).value; 
	}

	case 119: // expression ::= contextValueExpr 
	{
		 return (ResetableValueExpression) myStack.peek(0).value; 
	}

	case 12: // statment ::= ifStat 
	case 13: // statment ::= forInStat 
	case 14: // statment ::= forMapStat 
	case 15: // statment ::= whileStat 
	case 16: // statment ::= switchStat 
	{
		 return (Statment) myStack.peek(0).value; 
	}

	case 123: // contextValueIdent ::= IDENTIFIER 
	{
		 return (String) myStack.peek(0).value; 
	}

	case 121: // superCount ::= SUPER DOT 
	{
		 return 1; 
	}

	case 9: // statment ::= SEMICOLON 
	case 19: // statment ::= varStatmentPart SEMICOLON 
	{
		 return NoneStatment.getInstance(); 
	}

	case 4: // classPureName ::= IDENTIFIER 
	{
		 return new ClassNameBand((String) myStack.peek(0).value); 
	}

	case 143: // classNameList ::= 
	{
		 return new ClassNameList(this.nativeImportMgr); 
	}

	case 128: // expressionList1 ::= expression 
	{
		 return new ExpressionList().add((Expression) myStack.peek(0).value); 
	}

	case 130: // expressionList ::= 
	{
		 return new ExpressionList(); 
	}

	case 132: // mapKeyValue ::= DIRECT_VALUE COLON expression 
	{
		 return new MapKeyValue().add((Object) myStack.peek(2).value, (Expression) myStack.peek(0).value); 
	}

	case 2: // statmentList ::= 
	{
		 return new StatmentList(); 
	}

	case 67: // switchStatPart0 ::= 
	{
		 return new SwitchStatmentPart(); 
	}

	case 10: // statment ::= expression PLACE_HOLDER_END 
	{
		 return placeHolderStatmentFactory.creatPlaceHolderStatment((Expression) myStack.peek(1).value); 
	}

	case 42: // blockStatPrepare ::= 
	case 43: // blockStatPrepare2 ::= LBRACE 
	{
		 varmgr.push(); return null; 
	}

	case 1: // $START ::= templateAST EOF 
	{
		/* ACCEPT */
		this.goonParse = false;
		return myStack.peek(1).value;
	}

	case 139: // funcExecuteExpr ::= expression LPAREN expressionList RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol funcExpr$Symbol = myStack.peek(3);
		 return new FunctionExecuteExpression((Expression) funcExpr$Symbol.value, ((ExpressionList) myStack.peek(1).value).toArray(), funcExpr$Symbol.line, funcExpr$Symbol.column); 
	}

	case 140: // funcExecuteExpr ::= expression AT contextValueExpr LPAREN expressionList RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol funcExpr$Symbol = myStack.peek(3);
		 return new FunctionExecuteExpression((ResetableValueExpression) funcExpr$Symbol.value, ((ExpressionList) myStack.peek(1).value).addFirst((Expression) myStack.peek(5).value).toArray(), funcExpr$Symbol.line, funcExpr$Symbol.column); 
	}

	case 136: // funcHead ::= funcHeadPrepare IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((FunctionPart) myStack.peek(1).value).appendArgIndexs(varmgr.assignVariant((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 137: // funcHead ::= funcHead COMMA IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((FunctionPart) myStack.peek(2).value).appendArgIndexs(varmgr.assignVariant((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 38: // importStatPart2 ::= importStatPart1 IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((ImportStatmentPart) myStack.peek(1).value).append((String) ident$Symbol.value, createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 40: // importStatPart2 ::= importStatPart2 COMMA IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((ImportStatmentPart) myStack.peek(2).value).append((String) ident$Symbol.value, createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 127: // contextValueExpr ::= superCount contextValueIdent 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return createContextValue((Integer) myStack.peek(1).value, (String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column); 
	}

	case 125: // contextValueExpr ::= contextValueIdent 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column); 
	}

	case 126: // contextValueExpr ::= THIS DOT contextValueIdent 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return createContextValue(0, (String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column); 
	}

	case 33: // varStatmentPart ::= VAR IDENTIFIER 
	case 34: // varStatmentPart ::= varStatmentPart COMMA IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 varmgr.assignVariant((String) ident$Symbol.value,ident$Symbol.line,ident$Symbol.column); return null;
	}

	case 74: // expression_statmentable ::= VAR IDENTIFIER EQ expression 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(2);
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 varmgr.assignVariant((String) ident$Symbol.value,ident$Symbol.line,ident$Symbol.column);
        return new AssignOperator(createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column), (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 142: // classNameList1 ::= classNameList1 COMMA className 
	{
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return ((ClassNameList) myStack.peek(2).value).add((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column); 
	}

	case 141: // classNameList1 ::= className 
	{
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return new ClassNameList(this.nativeImportMgr).add((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column); 
	}

	case 66: // caseBlockStat ::= blockStatPrepare statmentList 
	{
		webit.script.core.java_cup.runtime.Symbol prepare$Symbol = myStack.peek(1);
		 return ((StatmentList) myStack.peek(0).value).popIBlockStatment(varmgr.pop(), prepare$Symbol.line, prepare$Symbol.column); 
	}

	case 44: // blockStat ::= blockStatPrepare2 statmentList RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol prepare$Symbol = myStack.peek(2);
		 return ((StatmentList) myStack.peek(1).value).popIBlockStatment(varmgr.pop(), prepare$Symbol.line, prepare$Symbol.column); 
	}

	case 110: // expression ::= DIRECT_VALUE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return new DirectValue((Object) sym$Symbol.value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 78: // expression_statmentable ::= expression MINUSMINUS 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return new MinusMinusAfterOperator(castToResetableValueExpression((Expression) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 76: // expression_statmentable ::= expression PLUSPLUS 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return new PlusPlusAfterOperator(castToResetableValueExpression((Expression) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 18: // statment ::= TEXT_STATMENT 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return textStatmentFactory.getTextStatment(template, (char[]) sym$Symbol.value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 83: // expression ::= COMP expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return StatmentUtil.optimize(new BitNotOperator((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 84: // expression ::= MINUS expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return StatmentUtil.optimize(new NegativeOperator((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 85: // expression ::= NOT expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return StatmentUtil.optimize(new NotOperator((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 88: // expression ::= expression MULT expression 
	case 89: // expression ::= expression DIV expression 
	case 90: // expression ::= expression MOD expression 
	case 91: // expression ::= expression PLUS expression 
	case 92: // expression ::= expression MINUS expression 
	case 93: // expression ::= expression LSHIFT expression 
	case 94: // expression ::= expression RSHIFT expression 
	case 95: // expression ::= expression URSHIFT expression 
	case 96: // expression ::= expression LT expression 
	case 97: // expression ::= expression LTEQ expression 
	case 98: // expression ::= expression GT expression 
	case 99: // expression ::= expression GTEQ expression 
	case 100: // expression ::= expression EQEQ expression 
	case 101: // expression ::= expression NOTEQ expression 
	case 102: // expression ::= expression AND expression 
	case 103: // expression ::= expression OR expression 
	case 104: // expression ::= expression XOR expression 
	case 105: // expression ::= expression ANDAND expression 
	case 106: // expression ::= expression DOTDOT expression 
	case 107: // expression ::= expression OROR expression 
	case 108: // expression ::= expression QUESTION_COLON expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return createBinaryOperator((Expression) myStack.peek(2).value, (Integer) sym$Symbol.value, (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 79: // expression_statmentable ::= expression SELFEQ expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return createSelfOperator((Expression) myStack.peek(2).value, (Integer) sym$Symbol.value, (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 73: // expression_statmentable ::= expression EQ expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new AssignOperator(castToResetableValueExpression((Expression) myStack.peek(2).value), (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 22: // statment ::= BREAK SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new BreakStatment(0, sym$Symbol.line, sym$Symbol.column); 
	}

	case 24: // statment ::= CONTINUE SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ContinueStatment(0, sym$Symbol.line, sym$Symbol.column); 
	}

	case 35: // importStatPart1 ::= IMPORT expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ImportStatmentPart((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 135: // mapValue ::= LBRACE RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new MapValue(new Object[0], new Expression[0], sym$Symbol.line,sym$Symbol.column); 
	}

	case 77: // expression_statmentable ::= MINUSMINUS expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new MinusMinusBeforeOperator(castToResetableValueExpression((Expression) myStack.peek(0).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 75: // expression_statmentable ::= PLUSPLUS expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new PlusPlusBeforeOperator(castToResetableValueExpression((Expression) myStack.peek(0).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 86: // expression ::= expression DOT IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new PropertyOperator((Expression) myStack.peek(2).value, (String) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 80: // expression_statmentable ::= funcExecuteExpr EQGT expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new RedirectOutExpression((Expression) myStack.peek(2).value, castToResetableValueExpression((Expression) myStack.peek(0).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 26: // statment ::= RETURN SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ReturnStatment(null, sym$Symbol.line, sym$Symbol.column); 
	}

	case 138: // funcHeadPrepare ::= FUNCTION LPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 varmgr.push(); varmgr.pushVarWall(); return new FunctionPart(sym$Symbol.line,sym$Symbol.column).setArgsIndex(varmgr.assignVariant("arguments", sym$Symbol.line,sym$Symbol.column)); 
	}

	case 21: // statment ::= NATIVE_IMPORT classPureName SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 nativeImportMgr.registClass((ClassNameBand) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); return NoneStatment.getInstance(); 
	}

	case 134: // mapValue ::= LBRACE mapKeyValue RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return ((MapKeyValue) myStack.peek(1).value).pop(sym$Symbol.line, sym$Symbol.column); 
	}

	case 114: // expression ::= LBRACK expressionList RBRACK 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ArrayValue(((ExpressionList) myStack.peek(1).value).toArray(), sym$Symbol.line, sym$Symbol.column); 
	}

	case 23: // statment ::= BREAK IDENTIFIER SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new BreakStatment(getLabelIndex((String) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 25: // statment ::= CONTINUE IDENTIFIER SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ContinueStatment(getLabelIndex((String) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 20: // statment ::= ECHO expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new EchoStatment((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 36: // importStatPart1 ::= IMPORT expression mapValue 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ImportStatmentPart((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column).setParamsExpr((MapValue) myStack.peek(0).value); 
	}

	case 30: // statment ::= INCLUDE expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new IncludeStatment((Expression) myStack.peek(1).value, null, sym$Symbol.line, sym$Symbol.column); 
	}

	case 87: // expression ::= expression LBRACK expression RBRACK 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new IndexOperator((Expression) myStack.peek(3).value, (Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 17: // statment ::= blockStat EQGT expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new RedirectOutStatment((IBlockStatment) myStack.peek(3).value, castToResetableValueExpression((Expression) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 27: // statment ::= RETURN expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ReturnStatment((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 69: // switchStatPart0 ::= DEFAULT COLON caseBlockStat switchStatPart0 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return ((SwitchStatmentPart) myStack.peek(0).value).appendCaseStatment(null, (IBlockStatment) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 63: // whileStatPart ::= DO blockStat whileStatPart0 SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return ((WhileStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(2).value).setPosition(sym$Symbol.line, sym$Symbol.column); 
	}

	case 109: // expression ::= expression QUESTION expression COLON expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return StatmentUtil.optimize(new IfOperator((Expression) myStack.peek(4).value, (Expression) myStack.peek(2).value, (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 31: // statment ::= INCLUDE expression mapValue SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return new IncludeStatment((Expression) myStack.peek(2).value, (MapValue) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 61: // whileStatPart0 ::= WHILE LPAREN expression RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return new WhileStatmentPart().setWhileExpr((Expression) myStack.peek(1).value).setDoWhileAtFirst(true).setPosition(sym$Symbol.line, sym$Symbol.column); 
	}

	case 115: // expression ::= NATIVE LBRACK RBRACK className 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return popNativeNewArrayDeclare(nativeImportMgr.toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 116: // expression ::= NATIVE LBRACK className RBRACK 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(1);
		 return popNativeNewArrayDeclare(nativeImportMgr.toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 68: // switchStatPart0 ::= CASE DIRECT_VALUE COLON caseBlockStat switchStatPart0 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		 return ((SwitchStatmentPart) myStack.peek(0).value).appendCaseStatment((Object) myStack.peek(3).value, (IBlockStatment) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 45: // ifStatPart ::= IF LPAREN expression RPAREN blockStat 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		 return new IfStatmentPart((Expression) myStack.peek(2).value, sym$Symbol.line, sym$Symbol.column).setThenStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 37: // importStatPart1 ::= IMPORT expression LBRACE expression RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		 return new ImportStatmentPart((Expression) myStack.peek(3).value, sym$Symbol.line, sym$Symbol.column).setParamsExpr((Expression) myStack.peek(1).value); 
	}

	case 49: // forInStatPart0 ::= FOR LPAREN IDENTIFIER COLON expression RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(5);
		 return createForInStatmentPart((String) myStack.peek(3).value, (Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 32: // statment ::= INCLUDE expression LBRACE expression RBRACE SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(5);
		 return new IncludeStatment((Expression) myStack.peek(4).value, (Expression) myStack.peek(2).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 118: // expression ::= NATIVE NEW classPureName LPAREN classNameList RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(5);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(3);
		 return popNativeConstructorDeclare(nativeImportMgr.toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column), (ClassNameList) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 70: // switchStatPart ::= SWITCH LPAREN expression RPAREN LBRACE switchStatPart0 RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(6);
		 return ((SwitchStatmentPart) myStack.peek(1).value).setSwitchExpr((Expression) myStack.peek(4).value).setPosition(sym$Symbol.line, sym$Symbol.column); 
	}

	case 117: // expression ::= NATIVE classPureName DOT IDENTIFIER LPAREN classNameList RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(6);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(5);
		 return popNativeMethodDeclare(nativeImportMgr.toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column), (String) myStack.peek(3).value, (ClassNameList) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 55: // forMapStatPart0 ::= FOR LPAREN IDENTIFIER COMMA IDENTIFIER COLON expression RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(7);
		 return createForMapStatmentPart((String) myStack.peek(5).value, (String) myStack.peek(3).value, (Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	default:
		throw new ParseException("Invalid action number found in internal parse table");

      }
  }

}
