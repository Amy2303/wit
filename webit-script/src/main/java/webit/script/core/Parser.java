
//----------------------------------------------------
// The following code was generated by CUP v0.12for-WebitScript-only
// Sun Oct 20 16:42:27 CST 2013
//----------------------------------------------------

package webit.script.core;

import java.util.HashMap;
import java.util.Map;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.method.*;
import webit.script.core.ast.statments.*;
import webit.script.core.java_cup.runtime.Stack;
import webit.script.core.java_cup.runtime.Symbol;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.StatmentUtil;

/** CUP v0.12for-WebitScript-only generated parser.
  * @version Sun Oct 20 16:42:27 CST 2013
  */
public class Parser extends webit.script.core.java_cup.runtime.lr_parser {



  /** Production table. */
  private static final short PRODUCTION_TABLE[][] = loadFromDataFile("Production");

  /** Parse-action table. */
  private static final short[][] ACTION_TABLE = loadFromDataFile("Action");

  /** <code>reduce_goto</code> table. */
  private static final short[][] REDUCE_TABLE = loadFromDataFile("Reduce");
  /** Indicates start state. */
  private final static int START_STATE = 0;


    public Parser() {
        super(START_STATE, PRODUCTION_TABLE, ACTION_TABLE, REDUCE_TABLE);
    }
    
    private Stack<Symbol> getStack() {
        return this._stack;
    }

    private final NativeImportManager nativeImportMgr = new NativeImportManager();
    private final VariantManager varmgr = new VariantManager();
    private final Map<String, Integer> labelsIndexMap = new HashMap<String, Integer>();
    {
        labelsIndexMap.put(null, 0);
    }
    private int currentLabelIndex = 0;
    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }
    
    private void registClass(ClassNameBand classNameBand, int line, int column) {
        try {
            nativeImportMgr.registClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }
    
    private Class<?> toClass(ClassNameBand classNameBand, int line, int column) {
        try {
            return nativeImportMgr.toClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private void pushVarMgrForFunction(){
        varmgr.push();
        varmgr.pushVarWall();
    }

    private int assignVariant(String ident, int line, int column) {
        try {
            return varmgr.assignVariant(ident);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private int locateVarAtUpstairForce(String name, int upstair, int line, int column) {
        try {
            return varmgr.locateAtUpstair(name, upstair, true);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private VarAddress locateVar(String name, int line, int column) {
        try {
            return varmgr.locate(name, this.locateVarForce);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private ForInStatmentPart createForInStatmentPart(String item, Expression items, int line, int column){
        try {
            int itemIndex = varmgr.assignVariantForNextBlock(item);
            int iterIndex = varmgr.assignVariantForNextBlock("for.iter");

            return new ForInStatmentPart(itemIndex, iterIndex, items, line, column);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private ForMapStatmentPart createForMapStatmentPart(String key, String value, Expression map, int line, int column){
        try {
            int keyIndex = varmgr.assignVariantForNextBlock(key);
            int valueIndex = varmgr.assignVariantForNextBlock(value);
            int iterIndex = varmgr.assignVariantForNextBlock("for.iter");

            return new ForMapStatmentPart(keyIndex, valueIndex, iterIndex, map, line, column);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private BlockStatmentPart createBlockStatmentPart(int line, int column) {
        varmgr.push();
        return new BlockStatmentPart(line, column);
    }

    private IBlockStatment createBlockStatment(BlockStatmentPart part) {
        return part.setVarMap(varmgr.pop()).pop();
    }

    private ResetableValueExpression createContextValue(String name, int line, int column) {
        VarAddress addr;
        return (addr = locateVar(name, line, column)).upstairs == 0
                ? new CurrentContextValue(addr.index, name, line, column)
                : new ContextValue(addr.upstairs, addr.index, name, line, column);
    }

    private ResetableValueExpression createContextValue(int upstair, String name, int line, int column) {
        int index = locateVarAtUpstairForce(name, upstair, line, column);
        return upstair == 0
                ? new CurrentContextValue(index, name, line, column)
                : new ContextValue(upstair, index, name, true, line, column);
    }

    private ResetableValueExpression castToResetableValueExpression(Expression rexpr, int line, int column) {
        if(rexpr instanceof ResetableValueExpression){
            return (ResetableValueExpression) rexpr;
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", line, column);
        }
    }

    private Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){
        ResetableValueExpression leftExpr = castToResetableValueExpression(lexpr, line, column);
        SelfOperator oper;
        switch (sym) {

            // (+ - * / %)=
            case Operators.PLUSEQ:
                oper = new SelfPlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MINUSEQ:
                oper = new SelfMinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MULTEQ:
                oper = new SelfMultOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.DIVEQ:
                oper = new SelfDivOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.MODEQ:
                oper = new SelfModOperator(leftExpr, rightExpr, line, column);
                break;

            // (<< >> >>>)=
            case Operators.LSHIFTEQ:
                oper = new SelfLShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.RSHIFTEQ:
                oper = new SelfRShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.URSHIFTEQ:
                oper = new SelfURShiftOperator(leftExpr, rightExpr, line, column);
                break;

            // (& ^ |)=
            case Operators.ANDEQ:
                oper = new SelfBitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.XOREQ:
                oper = new SelfBitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Operators.OREQ:
                oper = new SelfBitOrOperator(leftExpr, rightExpr, line, column);
                break;

            default:
                throw new ParseException("Unsupported Operator", line, column);
        }

        return StatmentUtil.optimize(oper);
    }

    private Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new AndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new DivOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new EqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new GreaterOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new LessOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new MinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new ModOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new MultOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new OrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new PlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStepOperator(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatmentUtil.optimize(oper);
    }


  protected final Object do_action(int act_id) throws ParseException {
      webit.script.core.java_cup.runtime.Stack<webit.script.core.java_cup.runtime.Symbol> myStack = this.getStack();

      /* select the action based on the action number */
      switch (act_id){
	case 137: // contextValueIdent ::= FOR DOT IDENTIFIER 
	{
		 return ("for." + (String) myStack.peek(0).value).intern(); 
	}

	case 120: // expression ::= arrayValuePart RBRACK 
	{
		 return ((ArrayValuePart) myStack.peek(1).value).pop(); 
	}

	case 142: // arrayValuePart ::= arrayValuePart COMMA expression 
	{
		 return ((ArrayValuePart) myStack.peek(2).value).append((Expression) myStack.peek(0).value); 
	}

	case 46: // blockStatPart ::= blockStatPart statment 
	case 70: // caseBlockStatPart ::= caseBlockStatPart statment 
	{
		 return ((BlockStatmentPart) myStack.peek(1).value).append((Statment) myStack.peek(0).value); 
	}

	case 5: // classPureName ::= classPureName DOT IDENTIFIER 
	{
		 return ((ClassNameBand) myStack.peek(2).value).append((String) myStack.peek(0).value); 
	}

	case 7: // className ::= className LBRACK RBRACK 
	{
		 return ((ClassNameBand) myStack.peek(2).value).plusArrayDepth(); 
	}

	case 56: // forInStat ::= forInStatPart 
	{
		 return ((ForInStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 54: // forInStatPart1 ::= IDENTIFIER COLON forInStatPart0 
	{
		 return ((ForInStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(2).value)); 
	}

	case 55: // forInStatPart ::= forInStatPart1 blockStat 
	{
		 return ((ForInStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 57: // forInStat ::= forInStatPart ELSE blockStat 
	{
		 return ((ForInStatmentPart) myStack.peek(2).value).setElseStatment((IBlockStatment) myStack.peek(0).value).pop(); 
	}

	case 62: // forMapStat ::= forMapStatPart 
	{
		 return ((ForMapStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 60: // forMapStatPart1 ::= IDENTIFIER COLON forMapStatPart0 
	{
		 return ((ForMapStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(2).value)); 
	}

	case 61: // forMapStatPart ::= forMapStatPart1 blockStat 
	{
		 return ((ForMapStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 63: // forMapStat ::= forMapStatPart ELSE blockStat 
	{
		 return ((ForMapStatmentPart) myStack.peek(2).value).setElseStatment((IBlockStatment) myStack.peek(0).value).pop(); 
	}

	case 157: // funcExecuteExprPart1 ::= funcExecuteExprPart0 expression 
	{
		 return ((FunctionExecuteExpressionPart) myStack.peek(1).value).append((Expression) myStack.peek(0).value); 
	}

	case 153: // funcExecuteExpr ::= funcExecuteExprPart0 RPAREN 
	case 154: // funcExecuteExpr ::= funcExecuteExprPart1 RPAREN 
	{
		 return ((FunctionExecuteExpressionPart) myStack.peek(1).value).pop(); 
	}

	case 158: // funcExecuteExprPart1 ::= funcExecuteExprPart1 COMMA expression 
	{
		 return ((FunctionExecuteExpressionPart) myStack.peek(2).value).append((Expression) myStack.peek(0).value); 
	}

	case 152: // funcPart ::= funcPart statment 
	{
		 return ((FunctionPart) myStack.peek(1).value).append((Statment) myStack.peek(0).value); 
	}

	case 49: // ifStat ::= ifStatPart 
	{
		 return ((IfStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 50: // ifStat ::= ifStatPart ELSE blockStat 
	{
		 return ((IfStatmentPart) myStack.peek(2).value).setElseStatment((IBlockStatment) myStack.peek(0).value).pop(); 
	}

	case 51: // ifStat ::= ifStatPart ELSE ifStat 
	{
		 return ((IfStatmentPart) myStack.peek(2).value).setElseStatment((Statment) myStack.peek(0).value).pop(); 
	}

	case 40: // importStat ::= importStatPart1 SEMICOLON 
	case 41: // importStat ::= importStatPart2 SEMICOLON 
	{
		 return ((ImportStatmentPart) myStack.peek(1).value).pop(); 
	}

	case 37: // importStatPart2 ::= importStatPart1 contextValueExpr EQ IDENTIFIER 
	{
		 return ((ImportStatmentPart) myStack.peek(3).value).append((String) myStack.peek(0).value, (ResetableValueExpression) myStack.peek(2).value); 
	}

	case 39: // importStatPart2 ::= importStatPart2 COMMA contextValueExpr EQ IDENTIFIER 
	{
		 return ((ImportStatmentPart) myStack.peek(4).value).append((String) myStack.peek(0).value, (ResetableValueExpression) myStack.peek(2).value); 
	}

	case 145: // mapValue ::= mapValuePart RBRACE 
	{
		 return ((MapValuePart) myStack.peek(1).value).pop(); 
	}

	case 144: // mapValuePart ::= mapValuePart COMMA directValue COLON expression 
	{
		 return ((MapValuePart) myStack.peek(4).value).append((Object) myStack.peek(2).value, (Expression) myStack.peek(0).value); 
	}

	case 124: // expression ::= nativeConstructorExprPart1 RPAREN 
	case 125: // expression ::= nativeConstructorExprPart RPAREN 
	{
		 return ((NativeConstructorDeclareExpressionPart) myStack.peek(1).value).pop(this.engine); 
	}

	case 122: // expression ::= nativeMethodExprPart RPAREN 
	case 123: // expression ::= nativeMethodExprPart1 RPAREN 
	{
		 return ((NativeMethodDeclareExpressionPart) myStack.peek(1).value).pop(this.engine); 
	}

	case 76: // switchStat ::= switchStatPart 
	{
		 return ((SwitchStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 77: // switchStat ::= IDENTIFIER COLON switchStatPart 
	{
		 return ((SwitchStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(2).value)).pop(); 
	}

	case 0: // templateAST ::= templateASTPart 
	{
		 return ((TemplateASTPart) myStack.peek(0).value).setVarMap(varmgr.pop()).pop(); 
	}

	case 2: // templateASTPart ::= templateASTPart statment 
	{
		 return ((TemplateASTPart) myStack.peek(1).value).append((Statment) myStack.peek(0).value); 
	}

	case 67: // whileStat ::= whileStatPart 
	{
		 return ((WhileStatmentPart) myStack.peek(0).value).pop(); 
	}

	case 68: // whileStat ::= IDENTIFIER whileStatPart 
	{
		 return ((WhileStatmentPart) myStack.peek(0).value).setLabel(getLabelIndex((String) myStack.peek(1).value)).pop(); 
	}

	case 65: // whileStatPart ::= whileStatPart0 blockStat 
	{
		 return ((WhileStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 130: // directValue ::= BOOLEAN_LITERAL 
	{
		 return (Boolean) myStack.peek(0).value; 
	}

	case 131: // directValue ::= CHARACTER_LITERAL 
	{
		 return (Character) myStack.peek(0).value; 
	}

	case 6: // className ::= classPureName 
	{
		 return (ClassNameBand) myStack.peek(0).value; 
	}

	case 86: // expression_stat ::= funcExecuteExpr 
	case 87: // expression ::= expression_stat 
	{
		 return (Expression) myStack.peek(0).value; 
	}

	case 8: // statment ::= expression_stat SEMICOLON 
	case 116: // expression ::= LPAREN expression RPAREN 
	{
		 return (Expression) myStack.peek(1).value; 
	}

	case 53: // forInStatPart1 ::= forInStatPart0 
	{
		 return (ForInStatmentPart) myStack.peek(0).value; 
	}

	case 59: // forMapStatPart1 ::= forMapStatPart0 
	{
		 return (ForMapStatmentPart) myStack.peek(0).value; 
	}

	case 150: // funcPart ::= funcPart0 RPAREN LBRACE 
	case 151: // funcPart ::= funcPart1 RPAREN LBRACE 
	{
		 return (FunctionPart) myStack.peek(2).value; 
	}

	case 12: // statment ::= blockStat 
	{
		 return (IBlockStatment) myStack.peek(0).value; 
	}

	case 135: // superCount ::= superCount SUPER DOT 
	{
		 return (Integer) myStack.peek(2).value + 1; 
	}

	case 127: // expression ::= mapValue 
	{
		 return (MapValue) myStack.peek(0).value; 
	}

	case 128: // directValue ::= INTEGER_LITERAL 
	case 129: // directValue ::= FLOATING_POINT_LITERAL 
	{
		 return (Number) myStack.peek(0).value; 
	}

	case 133: // directValue ::= NULL_LITERAL 
	{
		 return (Object) myStack.peek(0).value; 
	}

	case 126: // expression ::= contextValueExpr 
	{
		 return (ResetableValueExpression) myStack.peek(0).value; 
	}

	case 11: // statment ::= varStatment 
	case 13: // statment ::= ifStat 
	case 14: // statment ::= forInStat 
	case 15: // statment ::= forMapStat 
	case 16: // statment ::= whileStat 
	case 17: // statment ::= switchStat 
	case 18: // statment ::= importStat 
	case 19: // statment ::= includeStat 
	{
		 return (Statment) myStack.peek(0).value; 
	}

	case 132: // directValue ::= STRING_LITERAL 
	case 136: // contextValueIdent ::= IDENTIFIER 
	{
		 return (String) myStack.peek(0).value; 
	}

	case 134: // superCount ::= SUPER DOT 
	{
		 return 1; 
	}

	case 9: // statment ::= SEMICOLON 
	case 22: // statment ::= varStatmentPart SEMICOLON 
	{
		 return NoneStatment.getInstance(); 
	}

	case 71: // caseBlockStat ::= caseBlockStatPart 
	{
		 return createBlockStatment((BlockStatmentPart) myStack.peek(0).value); 
	}

	case 47: // blockStat ::= blockStatPart RBRACE 
	{
		 return createBlockStatment((BlockStatmentPart) myStack.peek(1).value); 
	}

	case 69: // caseBlockStatPart ::= 
	{
		 return createBlockStatmentPart(-1, -1); 
	}

	case 4: // classPureName ::= IDENTIFIER 
	{
		 return new ClassNameBand((String) myStack.peek(0).value); 
	}

	case 72: // switchStatPart0 ::= 
	{
		 return new SwitchStatmentPart(); 
	}

	case 3: // templateASTPart ::= 
	{
		 return new TemplateASTPart(); 
	}

	case 10: // statment ::= expression PLACE_HOLDER_END 
	{
		 return placeHolderStatmentFactory.creatPlaceHolderStatment((Expression) myStack.peek(1).value); 
	}

	case 1: // $START ::= templateAST EOF 
	{
		/* ACCEPT */
		this.goonParse = false;
		return myStack.peek(1).value;
	}

	case 155: // funcExecuteExprPart0 ::= expression LPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol funcExpr$Symbol = myStack.peek(1);
		 return new FunctionExecuteExpressionPart().setPosition(funcExpr$Symbol.line, funcExpr$Symbol.column).setFuncExpr((Expression) funcExpr$Symbol.value); 
	}

	case 156: // funcExecuteExprPart0 ::= expression AT contextValueExpr LPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol funcExpr$Symbol = myStack.peek(1);
		 return new FunctionExecuteExpressionPart().setPosition(funcExpr$Symbol.line, funcExpr$Symbol.column).setFuncExpr((ResetableValueExpression) funcExpr$Symbol.value).append((Expression) myStack.peek(3).value); 
	}

	case 31: // varStatmentPart ::= VAR IDENTIFIER 
	case 32: // varStatmentPart ::= varStatmentPart COMMA IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 assignVariant((String) ident$Symbol.value,ident$Symbol.line,ident$Symbol.column); return null;
	}

	case 148: // funcPart1 ::= funcPart0 IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((FunctionPart) myStack.peek(1).value).appendArgIndexs(assignVariant((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 149: // funcPart1 ::= funcPart1 COMMA IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((FunctionPart) myStack.peek(2).value).appendArgIndexs(assignVariant((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 36: // importStatPart2 ::= importStatPart1 IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((ImportStatmentPart) myStack.peek(1).value).append((String) ident$Symbol.value, createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 38: // importStatPart2 ::= importStatPart2 COMMA IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return ((ImportStatmentPart) myStack.peek(2).value).append((String) ident$Symbol.value, createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column)); 
	}

	case 140: // contextValueExpr ::= superCount contextValueIdent 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return createContextValue((Integer) myStack.peek(1).value, (String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column); 
	}

	case 138: // contextValueExpr ::= contextValueIdent 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column); 
	}

	case 139: // contextValueExpr ::= THIS DOT contextValueIdent 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(0);
		 return createContextValue(0, (String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column); 
	}

	case 79: // expression_stat ::= VAR IDENTIFIER EQ expression 
	{
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = myStack.peek(2);
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 assignVariant((String) ident$Symbol.value,ident$Symbol.line,ident$Symbol.column);
        return new AssignOperator(createContextValue((String) ident$Symbol.value, ident$Symbol.line, ident$Symbol.column), (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 163: // nativeConstructorExprPart ::= nativeConstructorExprPart1 className 
	{
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return ((NativeConstructorDeclareExpressionPart) myStack.peek(1).value).append(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column)); 
	}

	case 164: // nativeConstructorExprPart ::= nativeConstructorExprPart COMMA className 
	{
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return ((NativeConstructorDeclareExpressionPart) myStack.peek(2).value).append(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column)); 
	}

	case 160: // nativeMethodExprPart ::= nativeMethodExprPart1 className 
	{
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return ((NativeMethodDeclareExpressionPart) myStack.peek(1).value).append(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column)); 
	}

	case 161: // nativeMethodExprPart ::= nativeMethodExprPart COMMA className 
	{
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return ((NativeMethodDeclareExpressionPart) myStack.peek(2).value).append(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column)); 
	}

	case 119: // expression ::= funcPart RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol part$Symbol = myStack.peek(1);
		 return new FunctionDeclareExpression(
                ((FunctionPart) part$Symbol.value).setOverflowUpstairs(varmgr.popVarWall()).setVarMap(varmgr.pop()).pop(),
                part$Symbol.line, part$Symbol.column); 
	}

	case 45: // blockStatPart ::= LBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return createBlockStatmentPart(sym$Symbol.line, sym$Symbol.column); 
	}

	case 115: // expression ::= directValue 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return new DirectValue((Object) sym$Symbol.value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 83: // expression_stat ::= expression MINUSMINUS 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return new MinusMinusAfterOperator(castToResetableValueExpression((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 81: // expression_stat ::= expression PLUSPLUS 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return new PlusPlusAfterOperator(castToResetableValueExpression((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 21: // statment ::= TEXT_STATMENT 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(0);
		 return textStatmentFactory.getTextStatment(template, (char[]) sym$Symbol.value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 147: // funcPart0 ::= FUNCTION LPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 pushVarMgrForFunction(); return new FunctionPart(sym$Symbol.line, sym$Symbol.column).setArgsIndex(assignVariant("arguments", sym$Symbol.line, sym$Symbol.column)); 
	}

	case 88: // expression ::= COMP expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return StatmentUtil.optimize(new BitNotOperator((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 89: // expression ::= MINUS expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return StatmentUtil.optimize(new NegativeOperator((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 90: // expression ::= NOT expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return StatmentUtil.optimize(new NotOperator((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 93: // expression ::= expression MULT expression 
	case 94: // expression ::= expression DIV expression 
	case 95: // expression ::= expression MOD expression 
	case 96: // expression ::= expression PLUS expression 
	case 97: // expression ::= expression MINUS expression 
	case 98: // expression ::= expression LSHIFT expression 
	case 99: // expression ::= expression RSHIFT expression 
	case 100: // expression ::= expression URSHIFT expression 
	case 101: // expression ::= expression LT expression 
	case 102: // expression ::= expression LTEQ expression 
	case 103: // expression ::= expression GT expression 
	case 104: // expression ::= expression GTEQ expression 
	case 105: // expression ::= expression EQEQ expression 
	case 106: // expression ::= expression NOTEQ expression 
	case 107: // expression ::= expression AND expression 
	case 108: // expression ::= expression OR expression 
	case 109: // expression ::= expression XOR expression 
	case 110: // expression ::= expression ANDAND expression 
	case 111: // expression ::= expression DOTDOT expression 
	case 112: // expression ::= expression OROR expression 
	case 113: // expression ::= expression QUESTION_COLON expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return createBinaryOperator((Expression) myStack.peek(2).value, (Integer) sym$Symbol.value, (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 84: // expression_stat ::= expression SELFEQ expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return createSelfOperator((Expression) myStack.peek(2).value, (Integer) sym$Symbol.value, (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 121: // expression ::= LBRACK RBRACK 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ArrayValue(new Expression[0], sym$Symbol.line,sym$Symbol.column); 
	}

	case 141: // arrayValuePart ::= LBRACK expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ArrayValuePart(sym$Symbol.line, sym$Symbol.column).append((Expression) myStack.peek(0).value); 
	}

	case 78: // expression_stat ::= expression EQ expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new AssignOperator(castToResetableValueExpression((Expression) myStack.peek(2).value, sym$Symbol.line, sym$Symbol.column), (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 25: // statment ::= BREAK SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new BreakStatment(0, sym$Symbol.line, sym$Symbol.column); 
	}

	case 27: // statment ::= CONTINUE SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ContinueStatment(0, sym$Symbol.line, sym$Symbol.column); 
	}

	case 33: // importStatPart1 ::= IMPORT expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ImportStatmentPart((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 146: // mapValue ::= LBRACE RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new MapValue(new Object[0], new Expression[0], sym$Symbol.line,sym$Symbol.column); 
	}

	case 82: // expression_stat ::= MINUSMINUS expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new MinusMinusBeforeOperator(castToResetableValueExpression((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 80: // expression_stat ::= PLUSPLUS expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new PlusPlusBeforeOperator(castToResetableValueExpression((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 91: // expression ::= expression DOT IDENTIFIER 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new PropertyOperator((Expression) myStack.peek(2).value, (String) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 85: // expression_stat ::= funcExecuteExpr EQGT expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new RedirectOutExpression((Expression) myStack.peek(2).value, castToResetableValueExpression((Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 29: // statment ::= RETURN SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(1);
		 return new ReturnStatment(null, sym$Symbol.line, sym$Symbol.column); 
	}

	case 24: // statment ::= NATIVE_IMPORT classPureName SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 registClass((ClassNameBand) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); return NoneStatment.getInstance(); 
	}

	case 26: // statment ::= BREAK IDENTIFIER SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new BreakStatment(getLabelIndex((String) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 28: // statment ::= CONTINUE IDENTIFIER SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ContinueStatment(getLabelIndex((String) myStack.peek(1).value), sym$Symbol.line, sym$Symbol.column); 
	}

	case 23: // statment ::= ECHO expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new EchoStatment((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 34: // importStatPart1 ::= IMPORT expression mapValue 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ImportStatmentPart((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column).setParamsExpr((MapValue) myStack.peek(0).value); 
	}

	case 42: // includeStat ::= INCLUDE expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new IncludeStatment((Expression) myStack.peek(1).value, null, sym$Symbol.line, sym$Symbol.column); 
	}

	case 92: // expression ::= expression LBRACK expression RBRACK 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new IndexOperator((Expression) myStack.peek(3).value, (Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 20: // statment ::= blockStat EQGT expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new RedirectOutStatment((IBlockStatment) myStack.peek(3).value, castToResetableValueExpression((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column), sym$Symbol.line, sym$Symbol.column); 
	}

	case 30: // statment ::= RETURN expression SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(2);
		 return new ReturnStatment((Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 74: // switchStatPart0 ::= DEFAULT COLON caseBlockStat switchStatPart0 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return ((SwitchStatmentPart) myStack.peek(0).value).appendCaseStatment(null, (IBlockStatment) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 66: // whileStatPart ::= DO blockStat whileStatPart0 SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return ((WhileStatmentPart) myStack.peek(1).value).setBodyStatment((IBlockStatment) myStack.peek(2).value).setPosition(sym$Symbol.line, sym$Symbol.column); 
	}

	case 114: // expression ::= expression QUESTION expression COLON expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return StatmentUtil.optimize(new IfOperator((Expression) myStack.peek(4).value, (Expression) myStack.peek(2).value, (Expression) myStack.peek(0).value, sym$Symbol.line, sym$Symbol.column)); 
	}

	case 43: // includeStat ::= INCLUDE expression mapValue SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return new IncludeStatment((Expression) myStack.peek(2).value, (MapValue) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 143: // mapValuePart ::= LBRACE directValue COLON expression 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return new MapValuePart(sym$Symbol.line, sym$Symbol.column).append((Object) myStack.peek(2).value, (Expression) myStack.peek(0).value); 
	}

	case 64: // whileStatPart0 ::= WHILE LPAREN expression RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		 return new WhileStatmentPart().setWhileExpr((Expression) myStack.peek(1).value).setDoWhileAtFirst(true).setPosition(sym$Symbol.line, sym$Symbol.column); 
	}

	case 117: // expression ::= NATIVE LBRACK RBRACK className 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(0);
		 return new NativeNewArrayDeclareExpressionPart(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column).pop(this.engine); 
	}

	case 162: // nativeConstructorExprPart1 ::= NATIVE NEW classPureName LPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(1);
		 return new NativeConstructorDeclareExpressionPart(sym$Symbol.line, sym$Symbol.column).setClassName(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column)); 
	}

	case 118: // expression ::= NATIVE LBRACK className RBRACK 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(3);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(1);
		 return new NativeNewArrayDeclareExpressionPart(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column).pop(this.engine); 
	}

	case 73: // switchStatPart0 ::= CASE directValue COLON caseBlockStat switchStatPart0 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		 return ((SwitchStatmentPart) myStack.peek(0).value).appendCaseStatment((Object) myStack.peek(3).value, (IBlockStatment) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 48: // ifStatPart ::= IF LPAREN expression RPAREN blockStat 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		 return new IfStatmentPart((Expression) myStack.peek(2).value, sym$Symbol.line, sym$Symbol.column).setThenStatment((IBlockStatment) myStack.peek(0).value); 
	}

	case 35: // importStatPart1 ::= IMPORT expression LBRACE expression RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		 return new ImportStatmentPart((Expression) myStack.peek(3).value, sym$Symbol.line, sym$Symbol.column).setParamsExpr((Expression) myStack.peek(1).value); 
	}

	case 159: // nativeMethodExprPart1 ::= NATIVE classPureName DOT IDENTIFIER LPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(4);
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = myStack.peek(3);
		 return new NativeMethodDeclareExpressionPart(sym$Symbol.line, sym$Symbol.column).setClassName(toClass((ClassNameBand) nameBand$Symbol.value, nameBand$Symbol.line, nameBand$Symbol.column)).setMethodName((String) myStack.peek(1).value); 
	}

	case 52: // forInStatPart0 ::= FOR LPAREN IDENTIFIER COLON expression RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(5);
		 return createForInStatmentPart((String) myStack.peek(3).value, (Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 44: // includeStat ::= INCLUDE expression LBRACE expression RBRACE SEMICOLON 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(5);
		 return new IncludeStatment((Expression) myStack.peek(4).value, (Expression) myStack.peek(2).value, sym$Symbol.line, sym$Symbol.column); 
	}

	case 75: // switchStatPart ::= SWITCH LPAREN expression RPAREN LBRACE switchStatPart0 RBRACE 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(6);
		 return ((SwitchStatmentPart) myStack.peek(1).value).setSwitchExpr((Expression) myStack.peek(4).value).setPosition(sym$Symbol.line, sym$Symbol.column); 
	}

	case 58: // forMapStatPart0 ::= FOR LPAREN IDENTIFIER COMMA IDENTIFIER COLON expression RPAREN 
	{
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = myStack.peek(7);
		 return createForMapStatmentPart((String) myStack.peek(5).value, (String) myStack.peek(3).value, (Expression) myStack.peek(1).value, sym$Symbol.line, sym$Symbol.column); 
	}

	default:
		throw new ParseException("Invalid action number found in internal parse table");

      }
  }

}
