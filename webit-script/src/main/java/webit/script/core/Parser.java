
//----------------------------------------------------
// The following code was generated by CUP v0.12for-WebitScript-only
// Sat Oct 19 13:10:56 CST 2013
//----------------------------------------------------

package webit.script.core;

import java.util.HashMap;
import java.util.Map;
import webit.script.core.VariantManager.VarAddress;
import webit.script.core.ast.*;
import webit.script.core.ast.expressions.*;
import webit.script.core.ast.method.*;
import webit.script.core.ast.statments.*;
import webit.script.core.java_cup.runtime.Stack;
import webit.script.core.java_cup.runtime.Symbol;
import webit.script.exceptions.ParseException;
import webit.script.util.ClassNameBand;
import webit.script.util.StatmentUtil;

/** CUP v0.12for-WebitScript-only generated parser.
  * @version Sat Oct 19 13:10:56 CST 2013
  */
public class Parser extends webit.script.core.java_cup.runtime.lr_parser {



  /** Production table. */
  private static final short _production_table[][] = 
    loadFromDataFile("ProdTable");
  /** Parse-action table. */
  private static final short[][] _action_table = 
    loadFromDataFile("ActionTable");
  /** <code>reduce_goto</code> table. */
  private static final short[][] _reduce_table = 
    loadFromDataFile("ReduceTable");  /** Instance of action encapsulation class. */
  CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  protected Object do_action(int act_id) throws Exception {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_id);
  }

  /** Indicates start state. */
  private static int start_state() {return 0;}


    public Parser() {
        super(start_state(), _production_table, _action_table, _reduce_table);
    }
    
//    public Parser() {
//        super(start_state(), start_production(), EOF_sym(), error_sym(), _production_table, _action_table, _reduce_table);
//    }

    final boolean isLocateVarForce() {
        return this.locateVarForce;
    }
    
    final Stack<Symbol> getStack() {
        return this._stack;
    }

    final void done_parsing() {
        this.goonParse = false;
    }

    final Statment createTextStatment(char[] text, int line, int column) {
        return StatmentUtil.optimize(textStatmentFactory.getTextStatment(template, text, line, column));
    }
    
    final Statment createPlaceHolderStatment(Expression expr) {
        return StatmentUtil.optimize(placeHolderStatmentFactory.creatPlaceHolderStatment(expr));
    }
    
    final Expression pop(NativeNewArrayDeclareExpressionPart part){
        return part.pop(this.engine);
    }

    final Expression pop(NativeConstructorDeclareExpressionPart part) {
        return part.pop(this.engine);
    }
    
    final Expression pop(NativeMethodDeclareExpressionPart part) {
        return part.pop(this.engine);
    }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {

 

    //================ >>
    private Map<String, Integer> labelsIndexMap = new HashMap<String, Integer>();
    {
        labelsIndexMap.put(null, 0);
    }
    private int currentLabelIndex = 0;
    private int getLabelIndex(String label){
        Integer index;
        if ((index = labelsIndexMap.get(label)) == null) {
            labelsIndexMap.put(label, index = ++currentLabelIndex);
        }
        return index;
    }
    
    NativeImportManager nativeImportMgr = new NativeImportManager();
    
    private void registPackage(ClassNameBand classNameBand, int line, int column) {
        try {
            nativeImportMgr.registPackage(classNameBand.getClassPureName());
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private void registClass(ClassNameBand classNameBand, int line, int column) {
        try {
            nativeImportMgr.registClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }
    
    private Class<?> toClass(ClassNameBand classNameBand, int line, int column) {
        try {
            return nativeImportMgr.toClass(classNameBand);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    //================ >> 

    private VariantManager varmgr = new VariantManager();

    private void pushVarMgrForFunction(){
        varmgr.push();
        varmgr.pushVarWall();
    }

    private int assignVariant(String ident, int line, int column) {
        try {
            return varmgr.assignVariant(ident);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private int assignVariantForNextBlock(String name, int line, int column) {
        try {
            return varmgr.assignVariantForNextBlock(name);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private int locateVarAtUpstairForce(String name, int upstair, int line, int column) {
        try {
            return varmgr.locateAtUpstair(name, upstair, true);
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    private VarAddress locateVar(String name, int line, int column) {
        try {
            return varmgr.locate(name, parser.isLocateVarForce());
        } catch (ParseException e) {
            throw e.setPosition(line, column);
        }
    }

    //================ >> TemplateAST

    private TemplateASTPart createTemplateASTPart() {
        return new TemplateASTPart();
    }

    private TemplateAST createTemplateAST(TemplateASTPart part) {
        return part.setVarMap(varmgr.pop()).pop();
    }

    //================ >> Statment
    
    private Statment createIncludeStatment(Expression expr,Expression paramExpr, int line, int column){
        return new IncludeStatment(expr, paramExpr, line, column);
    }
                
    private ImportStatmentPart createImportStatmentPart(Expression expr, int line, int column){
        return new ImportStatmentPart(expr, line, column);
    }
        
    private Statment createEchoStatment(Expression expr, int line, int column){
        return new EchoStatment(expr, line, column);
    }
    
    private Statment createReturnStatment(Expression expr, int line, int column){
        return new ReturnStatment(expr, line, column);
    }

    private Statment createBreakStatment(String label, int line, int column) {
        return new BreakStatment(getLabelIndex(label), line, column);
    }

    private Statment createPlaceHolderStatment(Expression expr) {
        return parser.createPlaceHolderStatment(expr);
    }

    private Statment createContinueStatment(String label, int line, int column) {
        return new ContinueStatment(getLabelIndex(label), line, column);
    }

    private SwitchStatmentPart createSwitchStatmentPart(){
        return new SwitchStatmentPart();
    }

    private WhileStatmentPart createWhileStatmentPart(){
        return new WhileStatmentPart();
    }

    private FunctionPart createFunctionPart(int line, int column){
        return new FunctionPart(line, column);
    }

    private IfStatmentPart createIfStatmentPart(Expression ifexpr, int line, int column){
        return new IfStatmentPart(ifexpr, line, column);
    }

    private ForInStatmentPart createForInStatmentPart(String item, Expression items, int line, int column){
        
        int itemIndex = assignVariantForNextBlock(item, line, column);
        int iterIndex = assignVariantForNextBlock("for.iter", line, column);

        return new ForInStatmentPart(itemIndex, iterIndex, items, line, column);
    }

    private ForMapStatmentPart createForMapStatmentPart(String key, String value, Expression map, int line, int column){
        
        int keyIndex = assignVariantForNextBlock(key, line, column);
        int valueIndex = assignVariantForNextBlock(value, line, column);

        int iterIndex = assignVariantForNextBlock("for.iter", line, column);

        return new ForMapStatmentPart(keyIndex, valueIndex, iterIndex, map, line, column);
    }

    private Statment createTextStatment(char[] text, int line, int column) {
        return parser.createTextStatment(text, line, column);
    }

    private BlockStatmentPart createBlockStatmentPart(int line, int column) {
        varmgr.push();
        return new BlockStatmentPart(line, column);
    }

    private IBlockStatment createBlockStatment(BlockStatmentPart part) {

        Map<String, Integer> varMap = varmgr.pop();
        return part.setVarMap(varMap).pop();
    }
    //================ << Statment

    //================ >> Expression

    private ResetableValueExpression createContextValue(String name, int line, int column) {
        VarAddress addr = locateVar(name, line, column);
        return addr.upstairs == 0
                ? new CurrentContextValue(addr.index, name, line, column)
                : new ContextValue(addr.upstairs, addr.index, name, line, column);
    }

    private ResetableValueExpression createContextValue(int upstair, String name, int line, int column) {
        int index = locateVarAtUpstairForce(name, upstair, line, column);
        return upstair == 0
                ? new CurrentContextValue(index, name, line, column)
                : new ContextValue(upstair, index, name, true, line, column);
    }

    private DirectValue createDirectValue(Object value, int line, int column) {
        return new DirectValue(value, line, column);
    }

    private RedirectOutExpression createRedirectOutExpression(Expression srcExpr, Expression rexpr, int line, int column){
        if(rexpr instanceof ResetableValueExpression){
            ResetableValueExpression outExpr = (ResetableValueExpression) rexpr;
            return new RedirectOutExpression(srcExpr, outExpr, line, column);
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", line, column);
        }
    }

    private RedirectOutStatment createRedirectOutStatment(Statment srcStatment, Expression rexpr, int line, int column){
        if(rexpr instanceof ResetableValueExpression){
            ResetableValueExpression outExpr = (ResetableValueExpression) rexpr;
            return new RedirectOutStatment(srcStatment, outExpr, line, column);
        }else{
            throw new ParseException("Invalid expression to redirect out stream to, must be rewriteable", line, column);
        }
    }

    private FunctionDeclareExpression createFunctionDeclareExpression(FunctionPart part, int line, int column){
        Function function = part.setOverflowUpstairs(varmgr.popVarWall()).setVarMap(varmgr.pop()).pop();
        return new FunctionDeclareExpression(function, line, column);
    }

    private FunctionExecuteExpressionPart createFunctionExecuteExpressionPart(){
        return new FunctionExecuteExpressionPart();
    }

    private NativeMethodDeclareExpressionPart createNativeMethodDeclareExpressionPart(int line, int column){
        return new NativeMethodDeclareExpressionPart(line, column);
    }

    private NativeConstructorDeclareExpressionPart createNativeConstructorDeclareExpressionPart(int line, int column){
        return new NativeConstructorDeclareExpressionPart(line, column);
    }

    private Expression createNativeNewArrayDeclareExpression(Class componentType, int line, int column){
        return parser.pop(new NativeNewArrayDeclareExpressionPart(componentType, line, column));
    }

    //================ >> Expression - Operator
    private Expression createSelfOperator(Expression lexpr, int sym, Expression rightExpr, int line, int column){

        if(lexpr instanceof ResetableValueExpression){
            ResetableValueExpression leftExpr = (ResetableValueExpression) lexpr;
            SelfOperator oper;
            switch (sym) {

                // (+ - * / %)=
                case Operators.PLUSEQ:
                    oper = new SelfPlusOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.MINUSEQ:
                    oper = new SelfMinusOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.MULTEQ:
                    oper = new SelfMultOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.DIVEQ:
                    oper = new SelfDivOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.MODEQ:
                    oper = new SelfModOperator(leftExpr, rightExpr, line, column);
                    break;

                // (<< >> >>>)=
                case Operators.LSHIFTEQ:
                    oper = new SelfLShiftOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.RSHIFTEQ:
                    oper = new SelfRShiftOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.URSHIFTEQ:
                    oper = new SelfURShiftOperator(leftExpr, rightExpr, line, column);
                    break;

                // (& ^ |)=
                case Operators.ANDEQ:
                    oper = new SelfBitAndOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.XOREQ:
                    oper = new SelfBitXorOperator(leftExpr, rightExpr, line, column);
                    break;
                case Operators.OREQ:
                    oper = new SelfBitOrOperator(leftExpr, rightExpr, line, column);
                    break;

                default:
                    throw new ParseException("Unsupported Operator", line, column);
            }
            
            return StatmentUtil.optimize(oper);
        }else{
            throw new ParseException("Invalid left expression, must be rewriteable", line, column);
        }
    }

    private Expression createBinaryOperator(Expression leftExpr, int sym, Expression rightExpr, int line, int column) {

        BinaryOperator oper;
        switch (sym) {
            case Tokens.ANDAND: // &&
                oper = new AndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.AND: // &
                oper = new BitAndOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OR: // |
                oper = new BitOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.XOR: // ^
                oper = new BitXorOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DIV: // /
                oper = new DivOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.EQEQ: // ==
                oper = new EqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GTEQ: // >=
                oper = new GreaterEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.GT: // >
                oper = new GreaterOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LSHIFT: // <<
                oper = new LShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LTEQ: // <=
                oper = new LessEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.LT: // <
                oper = new LessOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MINUS: // -
                oper = new MinusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MOD: // %
                oper = new ModOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.MULT: // *
                oper = new MultOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.NOTEQ: // !=
                oper = new NotEqualsOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.OROR: // ||
                oper = new OrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.PLUS: // +
                oper = new PlusOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.RSHIFT: // >>
                oper = new RShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.URSHIFT: // >>>
                oper = new URShiftOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.QUESTION_COLON: // ?:
                oper = new IfOrOperator(leftExpr, rightExpr, line, column);
                break;
            case Tokens.DOTDOT: // ..
                oper = new IntStepOperator(leftExpr, rightExpr, line, column);
                break;
            default:
                throw new ParseException("Unsupported Operator", line, column);
        }
        return StatmentUtil.optimize(oper);
    }

    private ArrayValuePart createArrayValuePart(Expression expr, int line, int column){
        return new ArrayValuePart(line, column).append(expr);
    }

    private ArrayValue createEmptyArrayValue(int line, int column){
        return new ArrayValue(new Expression[0], line, column);
    }

    private MapValuePart createMapValuePart(Object key, Expression expr, int line, int column){
        return new MapValuePart(line, column).append(key, expr);
    }

    private MapValue createEmptyMapValue(int line, int column){
        return new MapValue(new Object[0], new Expression[0], line, column);
    }

    private Expression createAssignOperator(Expression lexpr, Expression expr, int line, int column) {
        if(lexpr instanceof ResetableValueExpression){
            return StatmentUtil.optimize(new AssignOperator((ResetableValueExpression)lexpr, expr, line, column));
        }else{
            throw new ParseException("Invalid left expression, must be rewriteable", line, column);
        }
    }

    private Expression createIfOperator(Expression ifExpr, Expression leftValueExpr, Expression rightValueExpr, int line, int column) {
        return StatmentUtil.optimize(new IfOperator(ifExpr, leftValueExpr, rightValueExpr, line, column));
    }

    private Expression createIndexOperator(Expression leftExpr, Expression rightExpr, int line, int column) {
        return StatmentUtil.optimize(new IndexOperator(leftExpr, rightExpr, line, column));
    }

    private Expression createNegativeOperator(Expression expr, int line, int column) {
        return StatmentUtil.optimize(new NegativeOperator(expr, line, column));
    }

    private Expression createBitNotOperator(Expression expr, int line, int column) {
        return StatmentUtil.optimize(new BitNotOperator(expr, line, column));
    }

    private Expression createNotOperator(Expression expr, int line, int column) {
        return StatmentUtil.optimize(new NotOperator(expr, line, column));
    }

    private Expression createPropertyOperator(Expression expr, String ident, int line, int column) {
        return StatmentUtil.optimize(new PropertyOperator(expr, ident, line, column));
    }

    private Expression createPlusPlusOperator(Expression expr, boolean executeAtFirst, int line, int column) {
        if(expr instanceof ResetableValueExpression){            
            return executeAtFirst
                    ? new PlusPlusBeforeOperator((ResetableValueExpression)expr, line, column)
                    : new PlusPlusAfterOperator((ResetableValueExpression)expr, line, column);
        }else{
            throw new ParseException("Invalid expression, must be rewriteable", line, column);
        }
    }

    private Expression createMinusMinusOperator(Expression expr, boolean executeAtFirst, int line, int column) {
        if(expr instanceof ResetableValueExpression){
            return executeAtFirst
                    ? new MinusMinusBeforeOperator((ResetableValueExpression)expr, line, column)
                    : new MinusMinusAfterOperator((ResetableValueExpression)expr, line, column);
        }else{
            throw new ParseException("Invalid expression, must be rewriteable", line, column);
        }
    }

    // ==============<< 


  private final Parser parser;

  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  protected final Object CUP$Parser$do_action(
    int                        CUP$Parser$act_id)
    throws ParseException
    {
      webit.script.core.java_cup.runtime.Stack<webit.script.core.java_cup.runtime.Symbol> CUP$Parser$stack = this.parser.getStack();
      //RESULT_DEBUG: /*
      Object RESULT;
      //RESULT_DEBUG: */

      /* select the action based on the action number */
      switch (CUP$Parser$act_id){
	case 0: // templateAST ::= templateASTPart 
	{
		//RESULT_DEBUG: TemplateAST RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		TemplateASTPart part = (TemplateASTPart) part$Symbol.value;
		 return createTemplateAST(part);
	}

	case 1: // $START ::= templateAST EOF 
	{
		/* ACCEPT */
		this.parser.done_parsing();
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(1).value;
	}

	case 2: // templateASTPart ::= templateASTPart statment 
	{
		//RESULT_DEBUG: TemplateASTPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		TemplateASTPart part = (TemplateASTPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol stat$Symbol = CUP$Parser$stack.peek(0);
		Statment stat = (Statment) stat$Symbol.value;
		 return part.append(stat);
	}

	case 3: // templateASTPart ::= 
	{
		//RESULT_DEBUG: TemplateASTPart RESULT;
		 return createTemplateASTPart();
	}

	case 4: // classPureName ::= IDENTIFIER 
	{
		//RESULT_DEBUG: ClassNameBand RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return new ClassNameBand(ident);
	}

	case 5: // classPureName ::= classPureName DOT IDENTIFIER 
	{
		//RESULT_DEBUG: ClassNameBand RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		ClassNameBand part = (ClassNameBand) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return part.append(ident);
	}

	case 6: // className ::= classPureName 
	{
		//RESULT_DEBUG: ClassNameBand RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 7: // className ::= className LBRACK RBRACK 
	{
		//RESULT_DEBUG: ClassNameBand RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		ClassNameBand part = (ClassNameBand) part$Symbol.value;
		 return part.plusArrayDepth();
	}

	case 8: // statment ::= expression_stat SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(1).value;
	}

	case 9: // statment ::= SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		 return NoneStatment.getInstance();
	}

	case 10: // statment ::= expression PLACE_HOLDER_END 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		 return createPlaceHolderStatment(expr);
	}

	case 11: // statment ::= varStatment 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 12: // statment ::= blockStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 13: // statment ::= ifStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 14: // statment ::= forInStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 15: // statment ::= forMapStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 16: // statment ::= whileStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 17: // statment ::= switchStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 18: // statment ::= importStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 19: // statment ::= includeStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 20: // statment ::= blockStat EQGT expression SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol stat$Symbol = CUP$Parser$stack.peek(3);
		IBlockStatment stat = (IBlockStatment) stat$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		 return createRedirectOutStatment(stat, expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 21: // statment ::= TEXT_STATMENT 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(0);
		char[] sym = (char[]) sym$Symbol.value;
		 return createTextStatment(sym, sym$Symbol.line, sym$Symbol.column);
	}

	case 22: // statment ::= varStatmentPart SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		 return NoneStatment.getInstance();
	}

	case 23: // statment ::= ECHO expression SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		 return createEchoStatment(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 24: // statment ::= NATIVE_IMPORT classPureName SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(1);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 registClass(nameBand, sym$Symbol.line, sym$Symbol.column); return NoneStatment.getInstance();
	}

	case 25: // statment ::= NATIVE_IMPORT classPureName DOT MULT SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(4);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(3);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 registPackage(nameBand, sym$Symbol.line, sym$Symbol.column); return NoneStatment.getInstance();
	}

	case 26: // statment ::= BREAK SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		 return createBreakStatment(null, sym$Symbol.line, sym$Symbol.column);
	}

	case 27: // statment ::= BREAK IDENTIFIER SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol label$Symbol = CUP$Parser$stack.peek(1);
		String label = (String) label$Symbol.value;
		 return createBreakStatment(label, sym$Symbol.line, sym$Symbol.column);
	}

	case 28: // statment ::= CONTINUE SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		 return createContinueStatment(null, sym$Symbol.line, sym$Symbol.column);
	}

	case 29: // statment ::= CONTINUE IDENTIFIER SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol label$Symbol = CUP$Parser$stack.peek(1);
		String label = (String) label$Symbol.value;
		 return createContinueStatment(label, sym$Symbol.line, sym$Symbol.column);
	}

	case 30: // statment ::= RETURN SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		 return createReturnStatment(null, sym$Symbol.line, sym$Symbol.column);
	}

	case 31: // statment ::= RETURN expression SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		 return createReturnStatment(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 32: // varStatmentPart ::= VAR IDENTIFIER 
	{
		//RESULT_DEBUG: Object RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 assignVariant(ident,ident$Symbol.line,ident$Symbol.column); return null;
	}

	case 33: // varStatmentPart ::= varStatmentPart COMMA IDENTIFIER 
	{
		//RESULT_DEBUG: Object RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 assignVariant(ident,ident$Symbol.line,ident$Symbol.column); return null;
	}

	case 34: // importStatPart1 ::= IMPORT expression 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createImportStatmentPart(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 35: // importStatPart1 ::= IMPORT expression mapValue 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol paramsExpr$Symbol = CUP$Parser$stack.peek(0);
		MapValue paramsExpr = (MapValue) paramsExpr$Symbol.value;
		 return createImportStatmentPart(expr, sym$Symbol.line, sym$Symbol.column).setParamsExpr(paramsExpr);
	}

	case 36: // importStatPart1 ::= IMPORT expression LBRACE expression RBRACE 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(4);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(3);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol paramsExpr$Symbol = CUP$Parser$stack.peek(1);
		Expression paramsExpr = (Expression) paramsExpr$Symbol.value;
		 return createImportStatmentPart(expr, sym$Symbol.line, sym$Symbol.column).setParamsExpr(paramsExpr);
	}

	case 37: // importStatPart2 ::= importStatPart1 IDENTIFIER 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		ImportStatmentPart part = (ImportStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return part.append(ident, createContextValue(ident, ident$Symbol.line, ident$Symbol.column));
	}

	case 38: // importStatPart2 ::= importStatPart1 contextValueExpr EQ IDENTIFIER 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(3);
		ImportStatmentPart part = (ImportStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol valueExpr$Symbol = CUP$Parser$stack.peek(2);
		ResetableValueExpression valueExpr = (ResetableValueExpression) valueExpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return part.append(ident, valueExpr);
	}

	case 39: // importStatPart2 ::= importStatPart2 COMMA IDENTIFIER 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		ImportStatmentPart part = (ImportStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return part.append(ident, createContextValue(ident, ident$Symbol.line, ident$Symbol.column));
	}

	case 40: // importStatPart2 ::= importStatPart2 COMMA contextValueExpr EQ IDENTIFIER 
	{
		//RESULT_DEBUG: ImportStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(4);
		ImportStatmentPart part = (ImportStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol valueExpr$Symbol = CUP$Parser$stack.peek(2);
		ResetableValueExpression valueExpr = (ResetableValueExpression) valueExpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return part.append(ident, valueExpr);
	}

	case 41: // importStat ::= importStatPart1 SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		ImportStatmentPart part = (ImportStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 42: // importStat ::= importStatPart2 SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		ImportStatmentPart part = (ImportStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 43: // includeStat ::= INCLUDE expression SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		 return createIncludeStatment(expr, null, sym$Symbol.line, sym$Symbol.column);
	}

	case 44: // includeStat ::= INCLUDE expression mapValue SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(2);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol paramsExpr$Symbol = CUP$Parser$stack.peek(1);
		MapValue paramsExpr = (MapValue) paramsExpr$Symbol.value;
		 return createIncludeStatment(expr, paramsExpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 45: // includeStat ::= INCLUDE expression LBRACE expression RBRACE SEMICOLON 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(5);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(4);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol paramsExpr$Symbol = CUP$Parser$stack.peek(2);
		Expression paramsExpr = (Expression) paramsExpr$Symbol.value;
		 return createIncludeStatment(expr, paramsExpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 46: // blockStatPart ::= LBRACE 
	{
		//RESULT_DEBUG: BlockStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(0);
		Integer sym = (Integer) sym$Symbol.value;
		 return createBlockStatmentPart(sym$Symbol.line, sym$Symbol.column);
	}

	case 47: // blockStatPart ::= blockStatPart statment 
	{
		//RESULT_DEBUG: BlockStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		BlockStatmentPart part = (BlockStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol stat$Symbol = CUP$Parser$stack.peek(0);
		Statment stat = (Statment) stat$Symbol.value;
		 return part.append(stat);
	}

	case 48: // blockStat ::= blockStatPart RBRACE 
	{
		//RESULT_DEBUG: IBlockStatment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		BlockStatmentPart part = (BlockStatmentPart) part$Symbol.value;
		 return createBlockStatment(part);
	}

	case 49: // ifStatPart ::= IF LPAREN expression RPAREN blockStat 
	{
		//RESULT_DEBUG: IfStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(4);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(2);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		 return createIfStatmentPart(expr, sym$Symbol.line, sym$Symbol.column).setThenStatment(body);
	}

	case 50: // ifStat ::= ifStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		IfStatmentPart part = (IfStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 51: // ifStat ::= ifStatPart ELSE blockStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		IfStatmentPart part = (IfStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol elseBody$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment elseBody = (IBlockStatment) elseBody$Symbol.value;
		 return part.setElseStatment(elseBody).pop();
	}

	case 52: // ifStat ::= ifStatPart ELSE ifStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		IfStatmentPart part = (IfStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol elseBody$Symbol = CUP$Parser$stack.peek(0);
		Statment elseBody = (Statment) elseBody$Symbol.value;
		 return part.setElseStatment(elseBody).pop();
	}

	case 53: // forInStatPart0 ::= FOR LPAREN IDENTIFIER COLON expression RPAREN 
	{
		//RESULT_DEBUG: ForInStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(5);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol item$Symbol = CUP$Parser$stack.peek(3);
		String item = (String) item$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol items$Symbol = CUP$Parser$stack.peek(1);
		Expression items = (Expression) items$Symbol.value;
		 return createForInStatmentPart(item, items, sym$Symbol.line, sym$Symbol.column);
	}

	case 54: // forInStatPart1 ::= forInStatPart0 
	{
		//RESULT_DEBUG: ForInStatmentPart RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 55: // forInStatPart1 ::= IDENTIFIER COLON forInStatPart0 
	{
		//RESULT_DEBUG: ForInStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol label$Symbol = CUP$Parser$stack.peek(2);
		String label = (String) label$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		ForInStatmentPart part = (ForInStatmentPart) part$Symbol.value;
		 return part.setLabel(getLabelIndex(label));
	}

	case 56: // forInStatPart ::= forInStatPart1 blockStat 
	{
		//RESULT_DEBUG: ForInStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		ForInStatmentPart part = (ForInStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		 return part.setBodyStatment(body);
	}

	case 57: // forInStat ::= forInStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		ForInStatmentPart part = (ForInStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 58: // forInStat ::= forInStatPart ELSE blockStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		ForInStatmentPart part = (ForInStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol elseBody$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment elseBody = (IBlockStatment) elseBody$Symbol.value;
		 return part.setElseStatment(elseBody).pop();
	}

	case 59: // forMapStatPart0 ::= FOR LPAREN IDENTIFIER COMMA IDENTIFIER COLON expression RPAREN 
	{
		//RESULT_DEBUG: ForMapStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(7);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol key$Symbol = CUP$Parser$stack.peek(5);
		String key = (String) key$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol value$Symbol = CUP$Parser$stack.peek(3);
		String value = (String) value$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol map$Symbol = CUP$Parser$stack.peek(1);
		Expression map = (Expression) map$Symbol.value;
		 return createForMapStatmentPart(key, value, map, sym$Symbol.line, sym$Symbol.column);
	}

	case 60: // forMapStatPart1 ::= forMapStatPart0 
	{
		//RESULT_DEBUG: ForMapStatmentPart RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 61: // forMapStatPart1 ::= IDENTIFIER COLON forMapStatPart0 
	{
		//RESULT_DEBUG: ForMapStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol label$Symbol = CUP$Parser$stack.peek(2);
		String label = (String) label$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		ForMapStatmentPart part = (ForMapStatmentPart) part$Symbol.value;
		 return part.setLabel(getLabelIndex(label));
	}

	case 62: // forMapStatPart ::= forMapStatPart1 blockStat 
	{
		//RESULT_DEBUG: ForMapStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		ForMapStatmentPart part = (ForMapStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		 return part.setBodyStatment(body);
	}

	case 63: // forMapStat ::= forMapStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		ForMapStatmentPart part = (ForMapStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 64: // forMapStat ::= forMapStatPart ELSE blockStat 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		ForMapStatmentPart part = (ForMapStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol elseBody$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment elseBody = (IBlockStatment) elseBody$Symbol.value;
		 return part.setElseStatment(elseBody).pop();
	}

	case 65: // whileStatPart0 ::= WHILE LPAREN expression RPAREN 
	{
		//RESULT_DEBUG: WhileStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol whileExpr$Symbol = CUP$Parser$stack.peek(1);
		Expression whileExpr = (Expression) whileExpr$Symbol.value;
		 return createWhileStatmentPart().setWhileExpr(whileExpr).setDoWhileAtFirst(true).setPosition(sym$Symbol.line, sym$Symbol.column);
	}

	case 66: // whileStatPart ::= whileStatPart0 blockStat 
	{
		//RESULT_DEBUG: WhileStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		WhileStatmentPart part = (WhileStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(0);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		 return part.setBodyStatment(body);
	}

	case 67: // whileStatPart ::= DO blockStat whileStatPart0 SEMICOLON 
	{
		//RESULT_DEBUG: WhileStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(2);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		WhileStatmentPart part = (WhileStatmentPart) part$Symbol.value;
		 return part.setBodyStatment(body).setPosition(sym$Symbol.line, sym$Symbol.column);
	}

	case 68: // whileStat ::= whileStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		WhileStatmentPart part = (WhileStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 69: // whileStat ::= IDENTIFIER whileStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol label$Symbol = CUP$Parser$stack.peek(1);
		String label = (String) label$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		WhileStatmentPart part = (WhileStatmentPart) part$Symbol.value;
		 return part.setLabel(getLabelIndex(label)).pop();
	}

	case 70: // caseBlockStatPart ::= 
	{
		//RESULT_DEBUG: BlockStatmentPart RESULT;
		 return createBlockStatmentPart(-1, -1);
	}

	case 71: // caseBlockStatPart ::= caseBlockStatPart statment 
	{
		//RESULT_DEBUG: BlockStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		BlockStatmentPart part = (BlockStatmentPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol stat$Symbol = CUP$Parser$stack.peek(0);
		Statment stat = (Statment) stat$Symbol.value;
		 return part.append(stat);
	}

	case 72: // caseBlockStat ::= caseBlockStatPart 
	{
		//RESULT_DEBUG: IBlockStatment RESULT;
		webit.script.core.java_cup.runtime.Symbol bodyPart$Symbol = CUP$Parser$stack.peek(0);
		BlockStatmentPart bodyPart = (BlockStatmentPart) bodyPart$Symbol.value;
		 return createBlockStatment(bodyPart);
	}

	case 73: // switchStatPart0 ::= 
	{
		//RESULT_DEBUG: SwitchStatmentPart RESULT;
		 return createSwitchStatmentPart();
	}

	case 74: // switchStatPart0 ::= CASE directValue COLON caseBlockStat switchStatPart0 
	{
		//RESULT_DEBUG: SwitchStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(4);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol key$Symbol = CUP$Parser$stack.peek(3);
		Object key = (Object) key$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(1);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		SwitchStatmentPart part = (SwitchStatmentPart) part$Symbol.value;
		 return part.appendCaseStatment(key, body, sym$Symbol.line, sym$Symbol.column);
	}

	case 75: // switchStatPart0 ::= DEFAULT COLON caseBlockStat switchStatPart0 
	{
		//RESULT_DEBUG: SwitchStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol body$Symbol = CUP$Parser$stack.peek(1);
		IBlockStatment body = (IBlockStatment) body$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		SwitchStatmentPart part = (SwitchStatmentPart) part$Symbol.value;
		 return part.appendCaseStatment(null, body, sym$Symbol.line, sym$Symbol.column);
	}

	case 76: // switchStatPart ::= SWITCH LPAREN expression RPAREN LBRACE switchStatPart0 RBRACE 
	{
		//RESULT_DEBUG: SwitchStatmentPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(6);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol switchExpr$Symbol = CUP$Parser$stack.peek(4);
		Expression switchExpr = (Expression) switchExpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		SwitchStatmentPart part = (SwitchStatmentPart) part$Symbol.value;
		 return part.setSwitchExpr(switchExpr).setPosition(sym$Symbol.line, sym$Symbol.column);
	}

	case 77: // switchStat ::= switchStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		SwitchStatmentPart part = (SwitchStatmentPart) part$Symbol.value;
		 return part.pop();
	}

	case 78: // switchStat ::= IDENTIFIER COLON switchStatPart 
	{
		//RESULT_DEBUG: Statment RESULT;
		webit.script.core.java_cup.runtime.Symbol label$Symbol = CUP$Parser$stack.peek(2);
		String label = (String) label$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(0);
		SwitchStatmentPart part = (SwitchStatmentPart) part$Symbol.value;
		 return part.setLabel(getLabelIndex(label)).pop();
	}

	case 79: // expression_stat ::= expression EQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return  createAssignOperator(lexpr,expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 80: // expression_stat ::= VAR IDENTIFIER EQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(2);
		String ident = (String) ident$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 assignVariant(ident,ident$Symbol.line,ident$Symbol.column); ResetableValueExpression valueExpr = createContextValue(ident, ident$Symbol.line, ident$Symbol.column); return createAssignOperator(valueExpr,expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 81: // expression_stat ::= PLUSPLUS expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createPlusPlusOperator(expr, true, sym$Symbol.line, sym$Symbol.column);
	}

	case 82: // expression_stat ::= expression PLUSPLUS 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(0);
		Integer sym = (Integer) sym$Symbol.value;
		 return createPlusPlusOperator(expr, false, sym$Symbol.line, sym$Symbol.column);
	}

	case 83: // expression_stat ::= MINUSMINUS expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createMinusMinusOperator(expr, true, sym$Symbol.line, sym$Symbol.column);
	}

	case 84: // expression_stat ::= expression MINUSMINUS 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(1);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(0);
		Integer sym = (Integer) sym$Symbol.value;
		 return createMinusMinusOperator(expr, false, sym$Symbol.line, sym$Symbol.column);
	}

	case 85: // expression_stat ::= expression SELFEQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createSelfOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 86: // expression_stat ::= funcExecuteExpr EQGT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol srcExpr$Symbol = CUP$Parser$stack.peek(2);
		Expression srcExpr = (Expression) srcExpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createRedirectOutExpression(srcExpr, expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 87: // expression_stat ::= funcExecuteExpr 
	{
		//RESULT_DEBUG: Expression RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 88: // expression ::= expression_stat 
	{
		//RESULT_DEBUG: Expression RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 89: // expression ::= COMP expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createBitNotOperator(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 90: // expression ::= MINUS expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createNegativeOperator(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 91: // expression ::= NOT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createNotOperator(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 92: // expression ::= expression DOT IDENTIFIER 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(2);
		Expression expr = (Expression) expr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return createPropertyOperator(expr, ident, sym$Symbol.line, sym$Symbol.column);
	}

	case 93: // expression ::= expression LBRACK expression RBRACK 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(3);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(2);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(1);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createIndexOperator(lexpr, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 94: // expression ::= expression MULT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 95: // expression ::= expression DIV expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 96: // expression ::= expression MOD expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 97: // expression ::= expression PLUS expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 98: // expression ::= expression MINUS expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 99: // expression ::= expression LSHIFT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 100: // expression ::= expression RSHIFT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 101: // expression ::= expression URSHIFT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 102: // expression ::= expression LT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 103: // expression ::= expression LTEQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 104: // expression ::= expression GT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 105: // expression ::= expression GTEQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 106: // expression ::= expression EQEQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 107: // expression ::= expression NOTEQ expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 108: // expression ::= expression AND expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 109: // expression ::= expression OR expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 110: // expression ::= expression XOR expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 111: // expression ::= expression ANDAND expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 112: // expression ::= expression DOTDOT expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 113: // expression ::= expression OROR expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 114: // expression ::= expression QUESTION_COLON expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createBinaryOperator(lexpr, sym, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 115: // expression ::= expression QUESTION expression COLON expression 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol ifexpr$Symbol = CUP$Parser$stack.peek(4);
		Expression ifexpr = (Expression) ifexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol lexpr$Symbol = CUP$Parser$stack.peek(2);
		Expression lexpr = (Expression) lexpr$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol rexpr$Symbol = CUP$Parser$stack.peek(0);
		Expression rexpr = (Expression) rexpr$Symbol.value;
		 return createIfOperator(ifexpr, lexpr, rexpr, sym$Symbol.line, sym$Symbol.column);
	}

	case 116: // expression ::= directValue 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(0);
		Object sym = (Object) sym$Symbol.value;
		 return createDirectValue(sym, sym$Symbol.line, sym$Symbol.column);
	}

	case 117: // expression ::= LPAREN expression RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		return CUP$Parser$stack.peek(1).value;
	}

	case 118: // expression ::= NATIVE LBRACK RBRACK className 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(0);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return createNativeNewArrayDeclareExpression(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column);
	}

	case 119: // expression ::= NATIVE LBRACK className RBRACK 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(1);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return createNativeNewArrayDeclareExpression(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column), sym$Symbol.line, sym$Symbol.column);
	}

	case 120: // expression ::= funcPart RBRACE 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		FunctionPart part = (FunctionPart) part$Symbol.value;
		 return createFunctionDeclareExpression(part, part$Symbol.line, part$Symbol.column);
	}

	case 121: // expression ::= arrayValuePart RBRACK 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		ArrayValuePart part = (ArrayValuePart) part$Symbol.value;
		 return part.pop();
	}

	case 122: // expression ::= LBRACK RBRACK 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		 return createEmptyArrayValue(sym$Symbol.line,sym$Symbol.column);
	}

	case 123: // expression ::= nativeMethodExprPart RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		NativeMethodDeclareExpressionPart part = (NativeMethodDeclareExpressionPart) part$Symbol.value;
		 return parser.pop(part);
	}

	case 124: // expression ::= nativeMethodExprPart1 RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		NativeMethodDeclareExpressionPart part = (NativeMethodDeclareExpressionPart) part$Symbol.value;
		 return parser.pop(part);
	}

	case 125: // expression ::= nativeConstructorExprPart1 RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		NativeConstructorDeclareExpressionPart part = (NativeConstructorDeclareExpressionPart) part$Symbol.value;
		 return parser.pop(part);
	}

	case 126: // expression ::= nativeConstructorExprPart RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		NativeConstructorDeclareExpressionPart part = (NativeConstructorDeclareExpressionPart) part$Symbol.value;
		 return parser.pop(part);
	}

	case 127: // expression ::= contextValueExpr 
	{
		//RESULT_DEBUG: Expression RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 128: // expression ::= mapValue 
	{
		//RESULT_DEBUG: Expression RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 129: // directValue ::= INTEGER_LITERAL 
	{
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 130: // directValue ::= FLOATING_POINT_LITERAL 
	{
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 131: // directValue ::= BOOLEAN_LITERAL 
	{
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 132: // directValue ::= CHARACTER_LITERAL 
	{
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 133: // directValue ::= STRING_LITERAL 
	{
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 134: // directValue ::= NULL_LITERAL 
	{
		//RESULT_DEBUG: Object RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 135: // superCount ::= SUPER DOT 
	{
		//RESULT_DEBUG: Integer RESULT;
		 return 1;
	}

	case 136: // superCount ::= superCount SUPER DOT 
	{
		//RESULT_DEBUG: Integer RESULT;
		webit.script.core.java_cup.runtime.Symbol count$Symbol = CUP$Parser$stack.peek(2);
		Integer count = (Integer) count$Symbol.value;
		 return count + 1;
	}

	case 137: // contextValueIdent ::= IDENTIFIER 
	{
		//RESULT_DEBUG: String RESULT;
		return CUP$Parser$stack.peek(0).value;
	}

	case 138: // contextValueIdent ::= FOR DOT IDENTIFIER 
	{
		//RESULT_DEBUG: String RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return ("for."+ident).intern();
	}

	case 139: // contextValueExpr ::= contextValueIdent 
	{
		//RESULT_DEBUG: ResetableValueExpression RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return createContextValue(ident, ident$Symbol.line, ident$Symbol.column);
	}

	case 140: // contextValueExpr ::= THIS DOT contextValueIdent 
	{
		//RESULT_DEBUG: ResetableValueExpression RESULT;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return createContextValue(0, ident, ident$Symbol.line, ident$Symbol.column);
	}

	case 141: // contextValueExpr ::= superCount contextValueIdent 
	{
		//RESULT_DEBUG: ResetableValueExpression RESULT;
		webit.script.core.java_cup.runtime.Symbol count$Symbol = CUP$Parser$stack.peek(1);
		Integer count = (Integer) count$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 return createContextValue(count, ident, ident$Symbol.line, ident$Symbol.column);
	}

	case 142: // arrayValuePart ::= LBRACK expression 
	{
		//RESULT_DEBUG: ArrayValuePart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createArrayValuePart(expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 143: // arrayValuePart ::= arrayValuePart COMMA expression 
	{
		//RESULT_DEBUG: ArrayValuePart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		ArrayValuePart part = (ArrayValuePart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return part.append(expr);
	}

	case 144: // mapValuePart ::= LBRACE directValue COLON expression 
	{
		//RESULT_DEBUG: MapValuePart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol key$Symbol = CUP$Parser$stack.peek(2);
		Object key = (Object) key$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return createMapValuePart(key, expr, sym$Symbol.line, sym$Symbol.column);
	}

	case 145: // mapValuePart ::= mapValuePart COMMA directValue COLON expression 
	{
		//RESULT_DEBUG: MapValuePart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(4);
		MapValuePart part = (MapValuePart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol key$Symbol = CUP$Parser$stack.peek(2);
		Object key = (Object) key$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return part.append(key, expr);
	}

	case 146: // mapValue ::= mapValuePart RBRACE 
	{
		//RESULT_DEBUG: MapValue RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		MapValuePart part = (MapValuePart) part$Symbol.value;
		 return part.pop();
	}

	case 147: // mapValue ::= LBRACE RBRACE 
	{
		//RESULT_DEBUG: MapValue RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		 return createEmptyMapValue(sym$Symbol.line,sym$Symbol.column);
	}

	case 148: // funcPart0 ::= FUNCTION LPAREN 
	{
		//RESULT_DEBUG: FunctionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(1);
		Integer sym = (Integer) sym$Symbol.value;
		 pushVarMgrForFunction(); int argsIndex = assignVariant("arguments", sym$Symbol.line, sym$Symbol.column); return createFunctionPart(sym$Symbol.line, sym$Symbol.column).setArgsIndex(argsIndex);
	}

	case 149: // funcPart1 ::= funcPart0 IDENTIFIER 
	{
		//RESULT_DEBUG: FunctionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		FunctionPart part = (FunctionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 int paramIndex = assignVariant(ident, ident$Symbol.line, ident$Symbol.column); return part.appendArgIndexs(paramIndex);
	}

	case 150: // funcPart1 ::= funcPart1 COMMA IDENTIFIER 
	{
		//RESULT_DEBUG: FunctionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		FunctionPart part = (FunctionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(0);
		String ident = (String) ident$Symbol.value;
		 int paramIndex = assignVariant(ident, ident$Symbol.line, ident$Symbol.column); return part.appendArgIndexs(paramIndex);
	}

	case 151: // funcPart ::= funcPart0 RPAREN LBRACE 
	{
		//RESULT_DEBUG: FunctionPart RESULT;
		return CUP$Parser$stack.peek(2).value;
	}

	case 152: // funcPart ::= funcPart1 RPAREN LBRACE 
	{
		//RESULT_DEBUG: FunctionPart RESULT;
		return CUP$Parser$stack.peek(2).value;
	}

	case 153: // funcPart ::= funcPart statment 
	{
		//RESULT_DEBUG: FunctionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		FunctionPart part = (FunctionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol stat$Symbol = CUP$Parser$stack.peek(0);
		Statment stat = (Statment) stat$Symbol.value;
		 return part.append(stat);
	}

	case 154: // funcExecuteExpr ::= funcExecuteExprPart0 RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		FunctionExecuteExpressionPart part = (FunctionExecuteExpressionPart) part$Symbol.value;
		 return part.pop();
	}

	case 155: // funcExecuteExpr ::= funcExecuteExprPart1 RPAREN 
	{
		//RESULT_DEBUG: Expression RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		FunctionExecuteExpressionPart part = (FunctionExecuteExpressionPart) part$Symbol.value;
		 return part.pop();
	}

	case 156: // funcExecuteExprPart0 ::= expression LPAREN 
	{
		//RESULT_DEBUG: FunctionExecuteExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol funcExpr$Symbol = CUP$Parser$stack.peek(1);
		Expression funcExpr = (Expression) funcExpr$Symbol.value;
		 return createFunctionExecuteExpressionPart().setPosition(funcExpr$Symbol.line, funcExpr$Symbol.column).setFuncExpr(funcExpr);
	}

	case 157: // funcExecuteExprPart0 ::= expression AT contextValueExpr LPAREN 
	{
		//RESULT_DEBUG: FunctionExecuteExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol param0$Symbol = CUP$Parser$stack.peek(3);
		Expression param0 = (Expression) param0$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol funcExpr$Symbol = CUP$Parser$stack.peek(1);
		ResetableValueExpression funcExpr = (ResetableValueExpression) funcExpr$Symbol.value;
		 return createFunctionExecuteExpressionPart().setPosition(funcExpr$Symbol.line, funcExpr$Symbol.column).setFuncExpr(funcExpr).append(param0);
	}

	case 158: // funcExecuteExprPart1 ::= funcExecuteExprPart0 expression 
	{
		//RESULT_DEBUG: FunctionExecuteExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		FunctionExecuteExpressionPart part = (FunctionExecuteExpressionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return part.append(expr);
	}

	case 159: // funcExecuteExprPart1 ::= funcExecuteExprPart1 COMMA expression 
	{
		//RESULT_DEBUG: FunctionExecuteExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		FunctionExecuteExpressionPart part = (FunctionExecuteExpressionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol expr$Symbol = CUP$Parser$stack.peek(0);
		Expression expr = (Expression) expr$Symbol.value;
		 return part.append(expr);
	}

	case 160: // nativeMethodExprPart1 ::= NATIVE classPureName DOT IDENTIFIER LPAREN 
	{
		//RESULT_DEBUG: NativeMethodDeclareExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(4);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(3);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol ident$Symbol = CUP$Parser$stack.peek(1);
		String ident = (String) ident$Symbol.value;
		 return createNativeMethodDeclareExpressionPart(sym$Symbol.line, sym$Symbol.column).setClassName(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column)).setMethodName(ident);
	}

	case 161: // nativeMethodExprPart ::= nativeMethodExprPart1 className 
	{
		//RESULT_DEBUG: NativeMethodDeclareExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		NativeMethodDeclareExpressionPart part = (NativeMethodDeclareExpressionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(0);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column));
	}

	case 162: // nativeMethodExprPart ::= nativeMethodExprPart COMMA className 
	{
		//RESULT_DEBUG: NativeMethodDeclareExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		NativeMethodDeclareExpressionPart part = (NativeMethodDeclareExpressionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(0);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column));
	}

	case 163: // nativeConstructorExprPart1 ::= NATIVE NEW classPureName LPAREN 
	{
		//RESULT_DEBUG: NativeConstructorDeclareExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol sym$Symbol = CUP$Parser$stack.peek(3);
		Integer sym = (Integer) sym$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(1);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return createNativeConstructorDeclareExpressionPart(sym$Symbol.line, sym$Symbol.column).setClassName(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column));
	}

	case 164: // nativeConstructorExprPart ::= nativeConstructorExprPart1 className 
	{
		//RESULT_DEBUG: NativeConstructorDeclareExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(1);
		NativeConstructorDeclareExpressionPart part = (NativeConstructorDeclareExpressionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(0);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column));
	}

	case 165: // nativeConstructorExprPart ::= nativeConstructorExprPart COMMA className 
	{
		//RESULT_DEBUG: NativeConstructorDeclareExpressionPart RESULT;
		webit.script.core.java_cup.runtime.Symbol part$Symbol = CUP$Parser$stack.peek(2);
		NativeConstructorDeclareExpressionPart part = (NativeConstructorDeclareExpressionPart) part$Symbol.value;
		webit.script.core.java_cup.runtime.Symbol nameBand$Symbol = CUP$Parser$stack.peek(0);
		ClassNameBand nameBand = (ClassNameBand) nameBand$Symbol.value;
		 return part.append(toClass(nameBand, nameBand$Symbol.line, nameBand$Symbol.column));
	}

          default:
            throw new ParseException("Invalid action number found in internal parse table");

        }
    }
}

