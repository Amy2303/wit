// Copyright (c) 2013, Webit Team. All Rights Reserved.
package webit.script.core.java_cup.runtime;

import java.io.IOException;
import webit.script.Engine;
import webit.script.Template;
import webit.script.core.Lexer;
import webit.script.core.ast.TemplateAST;
import webit.script.core.ast.statments.PlaceHolderStatmentFactory;
import webit.script.core.text.TextStatmentFactory;
import webit.script.exceptions.ParseException;
import webit.script.loggers.Logger;
import webit.script.util.ExceptionUtil;
import webit.script.util.StringUtil;

/**
 * This class implements a skeleton table driven LR parser. In general, LR
 * parsers are a form of bottom up shift-reduce parsers. Shift-reduce parsers
 * act by shifting input onto a parse _stack until the Symbols matching the
 * column hand side of a production appear on the top of the _stack. Once this
 * occurs, a reduce is performed. This involves removing the Symbols
 * corresponding to the column hand side of the production (the so called
 * "handle") and replacing them with the non-terminal from the line hand side of
 * the production. <p>
 *
 * To control the decision of whether to shift or reduce at any given point, the
 * parser uses a state machine (the "viable prefix recognition machine" built by
 * the parser generator). The current state of the machine is placed on top of
 * the parse _stack (stored as part of a Symbol object representing a terminal
 * or non terminal). The parse action table is consulted (using the current
 * state and the current lookahead Symbol as indexes) to determine whether to
 * shift or to reduce. When the parser shifts, it changes to a new state by
 * pushing a new Symbol (containing a new state) onto the _stack. When the
 * parser reduces, it pops the handle (column hand side of a production) off the
 * _stack. This leaves the parser in the state it was in before any of those
 * Symbols were matched. Next the reduce-goto table is consulted (using the new
 * state and current lookahead Symbol as indexes) to determine a new state to go
 * to. The parser then shifts to this goto state by pushing the line hand side
 * Symbol of the production (also containing the new state) onto the _stack.<p>
 *
 * This class actually provides four LR parsers. The methods parse() and
 * debug_parse() provide two versions of the main parser (the only difference
 * being that debug_parse() emits debugging trace messages as it parses). In
 * addition to these main parsers, the error recovery mechanism uses two more.
 * One of these is used to simulate "parsing ahead" in the input without
 * carrying out actions (to verify that a potential error recovery has worked),
 * and the other is used to parse through buffered "parse ahead" input in order
 * to execute all actions and re-synchronize the actual parser configuration.<p>
 *
 * This is an abstract class which is normally filled out by a subclass
 * generated by the JavaCup parser generator. In addition to supplying the
 * actual parse tables, generated code also supplies methods which invoke
 * various pieces of user supplied code, provide access to certain special
 * Symbols (e.g., EOF and error), etc. Specifically, the following abstract
 * methods are normally supplied by generated code:
 * <dl compact>
 * <dt> Symbol do_action()
 * <dd> Executes a piece of user supplied action code. This always comes at the
 * point of a reduce in the parse, so this code also allocates and fills in the
 * line hand side non terminal Symbol object that is to be pushed onto the
 * _stack for the reduce.
 * <dt> void init_actions()
 * <dd> Code to initialize a special object that encapsulates user supplied
 * actions (this object is used by do_action() to actually carry out the
 * actions).
 * </dl>
 *
 * In addition to these routines that <i>must</i> be supplied by the generated
 * subclass there are also a series of routines that <i>may</i>
 * be supplied. These include:
 * <dl>
 * <dt> Symbol scan()
 * <dd> Used to get the next input Symbol from the scanner.
 * <dt> int error_sync_size()
 * <dd> This determines how many Symbols past the point of an error must be
 * parsed without error in order to consider a recovery to be valid. This
 * defaults to 3. Values less than 2 are not recommended.
 * <dt> void report_error(String message, Object info)
 * <dd> This method is called to report an error. The default implementation
 * simply prints a message to System.err and where the error occurred. This
 * method is often replaced in order to provide a more sophisticated error
 * reporting mechanism.
 * <dt> void report_fatal_error(String message, Object info)
 * <dd> This method is called when a fatal error that cannot be recovered from
 * is encountered. In the default implementation, it calls report_error() to
 * emit a message, then throws an exception.
 * <dt> void syntax_error(Symbol cur_token)
 * <dd> This method is called as soon as syntax error is detected (but before
 * recovery is attempted). In the default implementation it invokes:
 * report_error("Syntax error", null);
 * <dt> void unrecovered_syntax_error(Symbol cur_token)
 * <dd> This method is called if syntax error recovery fails. In the default
 * implementation it invokes:<br>
 * report_fatal_error("Couldn't repair and continue parse", null);
 * </dl>
 *
 * @version last updated: 7/3/96
 * @author Frank Flannery
 */
public abstract class lr_parser {

    private final static int stackInitialCapacity = 24;

    public lr_parser(int startState, short[][] productionTable, short[][] actionTable, short[][] reduceTable) {
        this.startState = startState;
        this.productionTable = productionTable;
        this.actionTable = actionTable;
        this.reduceTable = reduceTable;
    }
//    public lr_parser(int start_state, int start_production, int EOF_sym, int error_sym, short[][] production_tab, short[][] action_tab, short[][] reduce_tab) {
//        this.start_state = start_state;
//        this.start_production = start_production;
//        this.EOF_sym = EOF_sym;
//        this.error_sym = error_sym;
//        this.production_tab = production_tab;
//        this.action_tab = action_tab;
//        this.reduce_tab = reduce_tab;
//    }
//    /**
//     * The default number of Symbols after an error we much match to consider it
//     * recovered from.
//     */
//    private final static int ERROR_SYNC_SIZE = 3;
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * The number of Symbols after an error we much match to consider it
//     * recovered from.
//     */
//    protected final int error_sync_size() {
//        return _error_sync_size;
//    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The index of the start state (supplied by generated subclass).
     */
    private final int startState;
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * The index of the start production (supplied by generated subclass).
//     */
//    private final int start_production;
//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * The index of the end of file terminal Symbol (supplied by generated
//     * subclass).
//     */
//    private final int EOF_sym;
//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * The index of the special error Symbol (supplied by generated subclass).
//     */
//    private final int error_sym;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Internal flag to indicate when parser should quit.
     */
    protected boolean goonParse = false;
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /* Global parse state shared by parse(), error recovery, and 
//     * debugging routines */
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * The current lookahead Symbol.
//     */
//    private Symbol cur_token;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The parse _stack itself.
     */
    protected final Stack<Symbol> _stack = new Stack<Symbol>(stackInitialCapacity);
    //private final String[] nonTerminalNames;
    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Direct reference to the production table.
     */
    private final short[][] productionTable;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Direct reference to the action table.
     */
    private final short[][] actionTable;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Direct reference to the reduce-goto table.
     */
    private final short[][] reduceTable;


    /*-----------------------------------------------------------*/
    /*--- General Methods ---------------------------------------*/
    /*-----------------------------------------------------------*/
    /**
     * Perform a bit of user supplied action code (supplied by generated
     * subclass). Actions are indexed by an internal action number assigned at
     * parser generation time.
     *
     * @param act_num the internal index of the action to be performed.
     * @param parser the parser object we are acting for.
     * @param _stack the parse _stack of that object.
     * @param top the index of the top element of the parse _stack.
     */
    protected abstract Object do_action(int act_num) throws Exception;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Initialize the action object. This is called before the parser does any
     * parse actions. This is filled in by generated code to create an object
     * that encapsulates all action code.
     */
    protected abstract void init_actions() throws Exception;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Get the next Symbol from the input (supplied by generated subclass). Once
     * end of file has been reached, all subsequent calls to scan should return
     * an EOF Symbol (which is Symbol number 0). By default this method returns
     * getScanner().next_token(); this implementation can be overriden by the
     * generated parser using the code declared in the "scan with" clause. Do
     * not recycle objects; every call to scan() should return a fresh object.
     */
    private Symbol nextToken() throws IOException {
        return lexer.nextToken();
    }

//    private void syntax_error(Symbol cur_token) {
//    }
    private void unrecoveredSyntaxError(Symbol cur_token) {
        throw new ParseException(StringUtil.concat("Parser stop at here, ", Integer.toString(getLine()), "(", Integer.toString(getColumn()), ")"), getLine(), getColumn());
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Fetch an action from the action table. The table is broken up into rows,
     * one per state (rows are indexed directly by state number). Within each
     * row, a list of index, value pairs are given (as sequential entries in the
     * table), and the list is terminated by a default entry (denoted with a
     * Symbol index of -1). To find the proper entry in a row we do a linear or
     * binary search (depending on the size of the row).
     *
     * @param state the state index of the action being accessed.
     * @param id the Symbol index of the action being accessed.
     */
    private short getAction(int state, int sym) {
        short tag;
        int first, last, probe, row_len;
        final short[] row = actionTable[state];

        /* linear search if we are < 10 entries */
        if ((row_len = row.length) < 20) {
            for (probe = 0; probe < row_len; probe++) {
                /* is this entry labeled with our Symbol or the default? */
                tag = row[probe++];
                if (tag == sym || tag == -1) {
                    /* return the next entry */
                    return row[probe];
                }
            }
        } else {
            /* otherwise binary search */
            first = 0;
            last = ((row_len - 1) >> 1) - 1;  /* leave out trailing default entry */
            int probe_2;
            while (first <= last) {
                probe = (first + last) >> 1;
                probe_2 = probe << 1;
                if (sym == row[probe_2]) {
                    return row[probe_2 + 1];
                } else if (sym > row[probe_2]) {
                    first = probe + 1;
                } else {
                    last = probe - 1;
                }
            }

            /* not found, use the default at the end */
            return row[row_len - 1];
        }

        /* shouldn't happened, but if we run off the end we return the 
         default (error == 0) */
        return 0;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Fetch a state from the reduce-goto table. The table is broken up into
     * rows, one per state (rows are indexed directly by state number). Within
     * each row, a list of index, value pairs are given (as sequential entries
     * in the table), and the list is terminated by a default entry (denoted
     * with a Symbol index of -1). To find the proper entry in a row we do a
     * linear search.
     *
     * @param state the state index of the entry being accessed.
     * @param id the Symbol index of the entry being accessed.
     */
    private short getReduce(int state, int sym) {
        int probe, len;
        short tag;
        final short[] row;
        for (probe = 0, len = (row = reduceTable[state]).length; probe < len; probe++) {
            /* is this entry labeled with our Symbol or the default? */
            if ((tag = row[probe++]) == sym || tag == -1) {
                /* return the next entry */
                return row[probe];
            }
        }
        /* if we run off the end we return the default (error == -1) */
        return -1;
    }
    //protected boolean symbolNoRightLeft = false;

    private void reduceAction(int action) throws Exception {
        final int symId, handleSize;
        final Object result = do_action(action);
        final short[] row;
        symId = (row = productionTable[action])[0];
        handleSize = row[1];

        //String symbolName = nonTerminalNames[symId];

        final Symbol sym;
        final Stack<Symbol> stack = this._stack;
        //if (symbolNoRightLeft || handleSize == 0) {
        if (handleSize == 0) {
            sym = newSymbol(symId, result);
        } else {
            //Symbol right = _stack.peek();
            //Symbol left = handleSize <= 1 ? right : _stack.peek(handleSize - 1);
            sym = newSymbol(symId, stack.peek(handleSize - 1), result);

            /* pops the handle off the _stack */
            stack.pops(handleSize);
        }

        /* look up the state to go to from the one popped back to */
        /* shift to that state */
        sym.state = getReduce(stack.peek().state, symId);
        stack.push(sym);

        //return sym;
    }
    protected Engine engine;
    protected Template template;
    protected TextStatmentFactory textStatmentFactory;
    protected PlaceHolderStatmentFactory placeHolderStatmentFactory;
    protected Logger logger;
    protected boolean locateVarForce;
    protected Lexer lexer;

    public final int getLine() {
        return lexer != null ? lexer.getLine() : 0;
    }

    public final int getColumn() {
        return lexer != null ? lexer.getColumn() : 0;
    }

    /**
     *
     * @param in java.io.Reader
     * @param template Template
     * @return TemplateAST
     * @throws ParseException
     */
    public TemplateAST parseTemplate(java.io.Reader in, Template template) throws ParseException {
        try {
            this.lexer = new Lexer(in);
            this.template = template;
            final Engine _engine;
            this.engine = _engine = template.engine;
            this.lexer.setTrimCodeBlockBlankLine(_engine.isTrimCodeBlockBlankLine());
            this.logger = _engine.getLogger();
            TextStatmentFactory _textStatmentFactory;
            this.textStatmentFactory = _textStatmentFactory = _engine.getTextStatmentFactory();
            this.locateVarForce = !_engine.isLooseVar();
            this.placeHolderStatmentFactory = new PlaceHolderStatmentFactory(_engine.getFilter());

            _textStatmentFactory.startTemplateParser(template);
            Symbol sym = this.parse();
            _textStatmentFactory.finishTemplateParser(template);
            return (TemplateAST) sym.value;
        } catch (Throwable e) {
            throw ExceptionUtil.castToParseException(e);
        } finally {
            try {
                this.lexer.yyclose();
            } catch (Exception e) {
                //ignore
            }
        }
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * This method provides the main parsing routine. It returns only when
     * finishParsing() has been called (typically because the parser has
     * accepted, or a fatal error has been reported). See the header
     * documentation for the class regarding how shift/reduce parsers operate
     * and how the various tables are used.
     */
    private Symbol parse() throws Exception {
        /* the current action code */
        int act;
        Symbol cur_token;
//        /* the Symbol/stack element returned by a reduce */
//        Symbol lhs_sym = null;

        /* initialize the action encapsulation object */
        init_actions();

        final Stack<Symbol> stack;
        (stack = this._stack).clear();
        //stack.push(newSymbol("START", 0, start_state()));
        {
            Symbol START;
            (START = newSymbol(0)).state = startState;
            stack.push(START);
        }

        /* get the first token */
        cur_token = nextToken();

        /* continue until we are told to stop */
        goonParse = true;
        do {

            /* current state is always on the top of the _stack */

            /* look up action out of the current state with the current input */
            act = getAction(stack.peek().state, cur_token.id);

            /* decode the action -- > 0 encodes shift */
            if (act > 0) {
                /* shift to the encoded state by pushing it on the _stack */
                cur_token.state = act - 1;
                stack.push(cur_token);

                /* advance to the next Symbol */
                cur_token = nextToken();
            } else if (act < 0) {
                /* if its less than zero, then it encodes a reduce action */
                /* perform the action for the reduce */
                //lhs_sym = reduceAction((-act) - 1);
                reduceAction((-act) - 1);
            } /*else if (act == 0) */ else {
                /* finally if the entry is zero, we have an error */

//                syntax_error(cur_token);
//
//                /* try to error recover */
//                if (!error_recovery()) {
                    /* if that fails give up with a fatal syntax error */
                this.goonParse = false;
                unrecoveredSyntaxError(cur_token);

//                } else {
//                    lhs_sym = _stack.peek();
//                }
            }
        } while (goonParse);

        return stack.peek();//lhs_sym;
    }

//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /* Error recovery code */
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * Attempt to recover from a syntax error. This returns false if recovery
//     * fails, true if it succeeds. Recovery happens in 4 steps. First we pops
//     * the parse _stack down to a point at which we have a shift out of the
//     * top-most state on the error Symbol. This represents the initial error
//     * recovery configuration. If no such configuration is found, then we fail.
//     * Next a small number of "lookahead" or "parse ahead" Symbols are read into
//     * a buffer. The size of this buffer is determined by error_sync_size() and
//     * determines how many Symbols beyond the error must be matched to consider
//     * the recovery a success. Next, we begin to discard Symbols in attempt to
//     * get past the point of error to a point where we can continue parsing.
//     * After each Symbol, we attempt to "parse ahead" though the buffered
//     * lookahead Symbols. The "parse ahead" process simulates that actual parse,
//     * but does not modify the real parser's configuration, nor execute any
//     * actions. If we can parse all the stored Symbols without error, then the
//     * recovery is considered a success. Once a successful recovery point is
//     * determined, we do an actual parse over the stored input -- modifying the
//     * real parse configuration and executing all actions. Finally, we return
//     * the the normal parser to continue with the overall parse.
//     *
//     */
//    private boolean error_recovery()
//            throws Exception {
//
//        /* first pops the _stack back into a state that can shift on error and 
//         do that shift (if that fails, we fail) */
//        if (!find_recovery_config()) {
//            return false;
//        }
//
//        /* read ahead to create lookahead we can parse multiple times */
//        {
//            //read_lookahead();
//            /* create the lookahead array */
//            lookahead = new Symbol[ERROR_SYNC_SIZE];
//
//            /* fill in the array */
//            for (int i = 0; i < ERROR_SYNC_SIZE; i++) {
//                lookahead[i] = cur_token;
//                cur_token = scan();
//            }
//
//            /* start at the beginning */
//            lookahead_pos = 0;
//        }
//
//        /* repeatedly try to parse forward until we make it the required dist */
//        for (;;) {
//            /* try to parse forward, if it makes it, bail out of loop */
//            if (try_parse_ahead()) {
//                break;
//            }
//
//            /* if we are now at EOF, we have failed */
//            if (lookahead[0].id == EOF_sym) {
//                return false;
//            }
//
//            /* otherwise, we consume another Symbol and try again */
//            // BUG FIX by Bruce Hutton
//            // Computer Science Department, University of Auckland,
//            // Auckland, New Zealand.
//            // It is the first token that is being consumed, not the one 
//            // we were up to parsing
//            {
//                //restart_lookahead();
//                /* move all the existing input over */
//                for (int i = 1; i < ERROR_SYNC_SIZE; i++) {
//                    lookahead[i - 1] = lookahead[i];
//                }
//
//                /* read a new Symbol into the last spot */
//                // BUG Fix by Bruce Hutton
//                // Computer Science Department, University of Auckland,
//                // Auckland, New Zealand. [applied 5-sep-1999 by csa]
//                // The following two lines were out of order!!
//                lookahead[ERROR_SYNC_SIZE - 1] = cur_token;
//                cur_token = scan();
//
//                /* reset our internal position marker */
//                lookahead_pos = 0;
//            }
//        }
//
//        /* we have consumed to a point where we can parse forward */
//
//        /* do the real parse (including actions) across the lookahead */
//        parse_lookahead();
//
//        /* we have success */
//        return true;
//    }
//
////    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
////    /**
////     * Determine if we can shift under the special error Symbol out of the state
////     * currently on the top of the (real) parse _stack.
////     */
////    private boolean shift_under_error() {
////        /* is there a shift under error Symbol */
////        return get_action(_stack.peek().state, error_sym()) > 0;
////    }
//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * Put the (real) parse _stack into error recovery configuration by popping
//     * the _stack down to a state that can shift on the special error Symbol,
//     * then doing the shift. If no suitable state exists on the _stack we return
//     * false
//     */
//    private boolean find_recovery_config() {//XXX:
//        Symbol error_token;
//        int act;
//
//        /* Remember the column-position of the top symbol on the _stack */
//        Symbol right = _stack.peek();// TUM 20060327 removed .column	
//        Symbol left = right;// TUM 20060327 removed .line	
//
//        /* pops down until we can shift under error Symbol */
//        //while (!shift_under_error()) {
//        while (get_action(_stack.peek().state, error_sym) <= 0) {
//            /* pops the _stack */
//            left = _stack.pop(); // TUM 20060327 removed .line	
//
//            /* if we have hit bottom, we fail */
//            if (_stack.empty()) {
//                return false;
//            }
//        }
//
//        /* state on top of the _stack can shift under error, find the shift */
//        act = get_action(_stack.peek().state, error_sym);
//
//        /* build and shift a special error Symbol */
//        error_token = newSymbol(error_sym, left);
//        error_token.state = act - 1;
//        _stack.push(error_token);
//
//        return true;
//    }
//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * Lookahead Symbols used for attempting error recovery "parse aheads".
//     */
//    private Symbol lookahead[];
//    /**
//     * Position in lookahead input buffer used for "parse ahead".
//     */
//    private int lookahead_pos;
//
////    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
////    /**
////     * Return the current lookahead in our error "parse ahead" buffer.
////     */
////    private Symbol cur_err_token() {
////        return lookahead[lookahead_pos];
////    }
//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * Reset the parse ahead input to one Symbol past where we started error
//     * recovery (this consumes one new Symbol from the real input).
//     */
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * Do a simulated parse forward (a "parse ahead") from the current _stack
//     * configuration using stored lookahead input and a virtual parse _stack.
//     * Return true if we make it all the way through the stored lookahead input
//     * without error. This basically simulates the action of parse() using only
//     * our saved "parse ahead" input, and not executing any actions.
//     *
//     */
//    private boolean try_parse_ahead()
//            throws Exception {
//        int act;
//        short lhs, rhs_size;
//
//        /* create a virtual _stack from the real parse _stack */
//        VirtualParseStack vstack = new VirtualParseStack(_stack);
//
//        /* parse until we fail or get past the lookahead input */
//        for (;;) {
//            /* look up the action from the current state (on top of _stack) */
//            act = get_action(vstack.top(), lookahead[lookahead_pos].id);
//
//            /* if its an error, we fail */
//            if (act == 0) {
//                return false;
//            }
//
//            /* > 0 encodes a shift */
//            if (act > 0) {
//                /* push the new state on the _stack */
//                vstack.push(act - 1);
//
//                /* advance simulated input, if we run off the end, we are done */
//                if ((++lookahead_pos) >= ERROR_SYNC_SIZE) {
//                    return true;
//                }
//            } /* < 0 encodes a reduce */ else {
//                /* if this is a reduce with the start production we are done */
//                if ((-act) - 1 == start_production) {
//                    return true;
//                }
//
//                /* get the lhs Symbol and the rhs size */
//                lhs = production_tab[(-act) - 1][0];
//                rhs_size = production_tab[(-act) - 1][1];
//
//                /* pops handle off the _stack */
//                for (int i = 0; i < rhs_size; i++) {
//                    vstack.pop();
//                }
//
//                /* look up goto and push it onto the _stack */
//                vstack.push(get_reduce(vstack.top(), lhs));
//            }
//        }
//    }
//
//    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//    /**
//     * Parse forward using stored lookahead Symbols. In this case we have
//     * already verified that parsing will make it through the stored lookahead
//     * Symbols and we are now getting back to the point at which we can hand
//     * control back to the normal parser. Consequently, this version of the
//     * parser performs all actions and modifies the real parse configuration.
//     * This returns once we have consumed all the stored input or we accept.
//     *
//     */
//    private void parse_lookahead()
//            throws Exception {
//        /* the current action code */
//        int act;
//
//        /* the Symbol/stack element returned by a reduce */
//        Symbol lhs_sym = null;
//
//
//        /* restart the saved input at the beginning */
//        lookahead_pos = 0;
//
//        Symbol cur_err_token;
//
//        /* continue until we accept or have read all lookahead input */
//        while (goonParse) {
//            /* current state is always on the top of the _stack */
//
//            cur_err_token = lookahead[lookahead_pos];
//            /* look up action out of the current state with the current input */
//            act = get_action(_stack.peek().state, cur_err_token.id);
//
//            /* decode the action -- > 0 encodes shift */
//            if (act > 0) {
//                /* shift to the encoded state by pushing it on the _stack */
//                cur_err_token.state = act - 1;
//
//                _stack.push(cur_err_token);
//
//                /* advance to the next Symbol, if there is none, we are done */
//                if ((++lookahead_pos) >= ERROR_SYNC_SIZE) {
//
//
//                    /* scan next Symbol so we can continue parse */
//                    // BUGFIX by Chris Harris <ckharris@ucsd.edu>:
//                    //   correct a one-off error by commenting out
//                    //   this next line.
//		  /*cur_token = scan();*/
//
//                    /* go back to normal parser */
//                    return;
//                }
//
//
//            } /* if its less than zero, then it encodes a reduce action */ else if (act < 0) {
//                /* perform the action for the reduce */
//
//
//                lhs_sym = reduce_action((-act) - 1);
//
//
//            } /* finally if the entry is zero, we have an error 
//             (shouldn't happen here, but...)*/ else if (act == 0) {
//                report_fatal_error("Syntax error", lhs_sym);
//                return;
//            }
//        }
//
//
//    }

    /*-----------------------------------------------------------*/
    /**
     * Utility function: unpacks parse tables from strings
     */
    protected static short[][] unpackFromStrings(String pack) {
        // Concatanate initialization strings.
        // location in initialization string
        int n, i, j, size2;
        short[] row;
        n = 0;
        int size1 = (((int) pack.charAt(n++)) << 16) | ((int) pack.charAt(n++));
        short[][] result = new short[size1][];
        i = 0;
        while (i < size1) {
            size2 = (((int) pack.charAt(n++)) << 16) | ((int) pack.charAt(n++));
            result[i++] = row = new short[size2];
            j = 0;
            while (j < size2) {
                row[j++] = (short) (pack.charAt(n++) - 2);
            }
        }
        return result;
    }

//    private final static class VirtualParseStack {
//
//        VirtualParseStack(Stack<Symbol> shadowing_stack) {
//
//            real_stack = shadowing_stack;
//            vstack = new Stack<Integer>(16);//XXX:
//            real_next = 0;
//
//            get_from_real();
//        }
//
//        /*-----------------------------------------------------------*/
//        /*--- (Access to) Instance Variables ------------------------*/
//        /*-----------------------------------------------------------*/
//        /**
//         * The real _stack that we shadow. This is accessed when we move off the
//         * bottom of the virtual portion of the _stack, but is always line
//         * unmodified.
//         */
//        private Stack<Symbol> real_stack;
//
//        /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//        /**
//         * Top of _stack indicator for where we leave off in the real _stack. This
//         * is measured from top of _stack, so 0 would indicate that no elements
//         * have been "moved" from the real to virtual _stack.
//         */
//        private int real_next;
//
//        /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
//        /**
//         * The virtual top portion of the _stack. This _stack contains Integer
//         * objects with state numbers. This _stack shadows the top portion of the
//         * real _stack within the area that has been modified (via operations on
//         * the virtual _stack). When this portion of the _stack becomes empty we
//         * transfer elements from the underlying _stack onto this _stack.
//         */
//        private Stack<Integer> vstack;
//
//        /*-----------------------------------------------------------*/
//        /*--- General Methods ---------------------------------------*/
//        /*-----------------------------------------------------------*/
//        /**
//         * Transfer an element from the real to the virtual _stack. This assumes
//         * that the virtual _stack is currently empty.
//         */
//        private void get_from_real() {
//            /* don't transfer if the real _stack is empty */
//            if (real_next >= real_stack.size()) {
//                return;
//            }
//
//            /* get a copy of the first Symbol we have not transfered */
//            Symbol stack_sym = real_stack.peek(real_next);
//
//            /* record the transfer */
//            real_next++;
//
//            /* put the state number from the Symbol onto the virtual _stack */
//            vstack.push(stack_sym.state);
//        }
//
//        boolean empty() {
//            return vstack.empty();
//        }
//
//        int top() {
//            return vstack.peek();
//        }
//
//        void pop() {
//            /* pops it */
//            vstack.pop();
//
//            /* if we are now empty transfer an element (if there is one) */
//            if (vstack.empty()) {
//                get_from_real();
//            }
//        }
//
//        void push(int state_num) {
//            vstack.push(state_num);
//        }
//    }
//    private static Symbol newSymbol(int id, Symbol left, Symbol right, Object value) {
//        return new Symbol(id, left.line, left.column, value);
//    }
    private static Symbol newSymbol(int id, Symbol left, Object value) {
        return new Symbol(id, left.line, left.column, value);
    }

//    private static Symbol newSymbol(int id, Symbol left) {
//        return newSymbol(id, left);
//    }
    private static Symbol newSymbol(int id) {
        return new Symbol(id, -1, -1, null);
    }

    private static Symbol newSymbol(int id, Object value) {
        return new Symbol(id, -1, -1, value);
    }
}
