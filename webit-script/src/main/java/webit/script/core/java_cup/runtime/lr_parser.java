// Copyright (c) 2013, Webit Team. All Rights Reserved.
package webit.script.core.java_cup.runtime;

import webit.script.Engine;
import webit.script.Template;
import webit.script.core.Lexer;
import webit.script.core.ast.TemplateAST;
import webit.script.core.ast.statments.PlaceHolderStatmentFactory;
import webit.script.core.text.TextStatmentFactory;
import webit.script.exceptions.ParserException;
import webit.script.loggers.Logger;
import webit.script.security.NativeSecurityManager;

/**
 * This class implements a skeleton table driven LR parser. In general, LR
 * parsers are a form of bottom up shift-reduce parsers. Shift-reduce parsers
 * act by shifting input onto a parse stack until the Symbols matching the
 * column hand side of a production appear on the top of the stack. Once this
 * occurs, a reduce is performed. This involves removing the Symbols
 * corresponding to the column hand side of the production (the so called
 * "handle") and replacing them with the non-terminal from the line hand side of
 * the production. <p>
 *
 * To control the decision of whether to shift or reduce at any given point, the
 * parser uses a state machine (the "viable prefix recognition machine" built by
 * the parser generator). The current state of the machine is placed on top of
 * the parse stack (stored as part of a Symbol object representing a terminal or
 * non terminal). The parse action table is consulted (using the current state
 * and the current lookahead Symbol as indexes) to determine whether to shift or
 * to reduce. When the parser shifts, it changes to a new state by pushing a new
 * Symbol (containing a new state) onto the stack. When the parser reduces, it
 * pops the handle (column hand side of a production) off the stack. This leaves
 * the parser in the state it was in before any of those Symbols were matched.
 * Next the reduce-goto table is consulted (using the new state and current
 * lookahead Symbol as indexes) to determine a new state to go to. The parser
 * then shifts to this goto state by pushing the line hand side Symbol of the
 * production (also containing the new state) onto the stack.<p>
 *
 * This class actually provides four LR parsers. The methods parse() and
 * debug_parse() provide two versions of the main parser (the only difference
 * being that debug_parse() emits debugging trace messages as it parses). In
 * addition to these main parsers, the error recovery mechanism uses two more.
 * One of these is used to simulate "parsing ahead" in the input without
 * carrying out actions (to verify that a potential error recovery has worked),
 * and the other is used to parse through buffered "parse ahead" input in order
 * to execute all actions and re-synchronize the actual parser configuration.<p>
 *
 * This is an abstract class which is normally filled out by a subclass
 * generated by the JavaCup parser generator. In addition to supplying the
 * actual parse tables, generated code also supplies methods which invoke
 * various pieces of user supplied code, provide access to certain special
 * Symbols (e.g., EOF and error), etc. Specifically, the following abstract
 * methods are normally supplied by generated code:
 * <dl compact>
 * <dt> short[][] production_table()
 * <dd> Provides a reference to the production table (indicating the index of
 * the line hand side non terminal and the length of the column hand side for
 * each production in the grammar).
 * <dt> short[][] action_table()
 * <dd> Provides a reference to the parse action table.
 * <dt> short[][] reduce_table()
 * <dd> Provides a reference to the reduce-goto table.
 * <dt> int start_state()
 * <dd> Indicates the index of the start state.
 * <dt> int start_production()
 * <dd> Indicates the index of the starting production.
 * <dt> int EOF_sym()
 * <dd> Indicates the index of the EOF Symbol.
 * <dt> int error_sym()
 * <dd> Indicates the index of the error Symbol.
 * <dt> Symbol do_action()
 * <dd> Executes a piece of user supplied action code. This always comes at the
 * point of a reduce in the parse, so this code also allocates and fills in the
 * line hand side non terminal Symbol object that is to be pushed onto the stack
 * for the reduce.
 * <dt> void init_actions()
 * <dd> Code to initialize a special object that encapsulates user supplied
 * actions (this object is used by do_action() to actually carry out the
 * actions).
 * </dl>
 *
 * In addition to these routines that <i>must</i> be supplied by the generated
 * subclass there are also a series of routines that <i>may</i>
 * be supplied. These include:
 * <dl>
 * <dt> Symbol scan()
 * <dd> Used to get the next input Symbol from the scanner.
 * <dt> Scanner getScanner()
 * <dd> Used to provide a scanner for the default implementation of scan().
 * <dt> int error_sync_size()
 * <dd> This determines how many Symbols past the point of an error must be
 * parsed without error in order to consider a recovery to be valid. This
 * defaults to 3. Values less than 2 are not recommended.
 * <dt> void report_error(String message, Object info)
 * <dd> This method is called to report an error. The default implementation
 * simply prints a message to System.err and where the error occurred. This
 * method is often replaced in order to provide a more sophisticated error
 * reporting mechanism.
 * <dt> void report_fatal_error(String message, Object info)
 * <dd> This method is called when a fatal error that cannot be recovered from
 * is encountered. In the default implementation, it calls report_error() to
 * emit a message, then throws an exception.
 * <dt> void syntax_error(Symbol cur_token)
 * <dd> This method is called as soon as syntax error is detected (but before
 * recovery is attempted). In the default implementation it invokes:
 * report_error("Syntax error", null);
 * <dt> void unrecovered_syntax_error(Symbol cur_token)
 * <dd> This method is called if syntax error recovery fails. In the default
 * implementation it invokes:<br>
 * report_fatal_error("Couldn't repair and continue parse", null);
 * </dl>
 *
 * @version last updated: 7/3/96
 * @author Frank Flannery
 */
public abstract class lr_parser {

    protected lr_parser(String[] nonTerminalNames, short[][] production_tab, short[][] action_tab, short[][] reduce_tab) {
        this.nonTerminalNames = nonTerminalNames;
        this.production_tab = production_tab;
        this.action_tab = action_tab;
        this.reduce_tab = reduce_tab;
        symbolFactory = new DefaultSymbolFactory();
    }
    protected SymbolFactory symbolFactory;// = new DefaultSymbolFactory();

    /*-----------------------------------------------------------*/
    /*--- (Access to) Static (Class) Variables ------------------*/
    /*-----------------------------------------------------------*/
    /**
     * The default number of Symbols after an error we much match to consider it
     * recovered from.
     */
    protected final static int _error_sync_size = 3;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The number of Symbols after an error we much match to consider it
     * recovered from.
     */
    protected final int error_sync_size() {
        return _error_sync_size;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The index of the start state (supplied by generated subclass).
     */
    protected abstract int start_state();

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The index of the start production (supplied by generated subclass).
     */
    protected abstract int start_production();

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The index of the end of file terminal Symbol (supplied by generated
     * subclass).
     */
    protected abstract int EOF_sym();

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The index of the special error Symbol (supplied by generated subclass).
     */
    protected abstract int error_sym();

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Internal flag to indicate when parser should quit.
     */
    protected boolean isParseDone = false;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * This method is called to indicate that the parser should quit. This is
     * normally called by an accept action, but can be used to cancel parsing
     * early in other circumstances if desired.
     */
    private void doneParse() {
        isParseDone = true;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /* Global parse state shared by parse(), error recovery, and 
     * debugging routines */
    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Indication of the index for top of stack (for use by actions).
     */
    protected int tos;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The current lookahead Symbol.
     */
    protected Symbol cur_token;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * The parse stack itself.
     */
    protected Stack<Symbol> stack = new ArrayStack<Symbol>();
    private final String[] nonTerminalNames;
    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Direct reference to the production table.
     */
    private final short[][] production_tab;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Direct reference to the action table.
     */
    private final short[][] action_tab;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Direct reference to the reduce-goto table.
     */
    private final short[][] reduce_tab;


    /*-----------------------------------------------------------*/
    /*--- General Methods ---------------------------------------*/
    /*-----------------------------------------------------------*/
    /**
     * Perform a bit of user supplied action code (supplied by generated
     * subclass). Actions are indexed by an internal action number assigned at
     * parser generation time.
     *
     * @param act_num the internal index of the action to be performed.
     * @param parser the parser object we are acting for.
     * @param stack the parse stack of that object.
     * @param top the index of the top element of the parse stack.
     */
    protected abstract Object do_action(
            int act_num)
            throws Exception;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * User code for initialization inside the parser. Typically this
     * initializes the scanner. This is called before the parser requests the
     * first Symbol. Here this is just a placeholder for subclasses that might
     * need this and we perform no action. This method is normally overridden by
     * the generated code using this contents of the "init with" clause as its
     * body.
     */
    protected void user_init() throws Exception {
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Initialize the action object. This is called before the parser does any
     * parse actions. This is filled in by generated code to create an object
     * that encapsulates all action code.
     */
    protected abstract void init_actions() throws Exception;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Get the next Symbol from the input (supplied by generated subclass). Once
     * end of file has been reached, all subsequent calls to scan should return
     * an EOF Symbol (which is Symbol number 0). By default this method returns
     * getScanner().next_token(); this implementation can be overriden by the
     * generated parser using the code declared in the "scan with" clause. Do
     * not recycle objects; every call to scan() should return a fresh object.
     */
    private Symbol scan() throws Exception {
        return lexer.next_token();
    }

    private void report_fatal_error(String message, Object info) {
        doneParse();
        throw new ParserException(message != null ? message : "Parser stop at here, ", getLine(), getColumn());
    }

    private void syntax_error(Symbol cur_token) {
    }

    private void unrecovered_syntax_error(Symbol cur_token) {
        report_fatal_error("Parser stop at here, and failed to recover ", cur_token);
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Fetch an action from the action table. The table is broken up into rows,
     * one per state (rows are indexed directly by state number). Within each
     * row, a list of index, value pairs are given (as sequential entries in the
     * table), and the list is terminated by a default entry (denoted with a
     * Symbol index of -1). To find the proper entry in a row we do a linear or
     * binary search (depending on the size of the row).
     *
     * @param state the state index of the action being accessed.
     * @param sym the Symbol index of the action being accessed.
     */
    private short get_action(int state, int sym) {
        short tag;
        int first, last, probe;
        final short[] row = action_tab[state];

        /* linear search if we are < 10 entries */
        if (row.length < 20) {
            for (probe = 0; probe < row.length; probe++) {
                /* is this entry labeled with our Symbol or the default? */
                tag = row[probe++];
                if (tag == sym || tag == -1) {
                    /* return the next entry */
                    return row[probe];
                }
            }
        } /* otherwise binary search */ else {
            first = 0;
            last = (row.length - 1) / 2 - 1;  /* leave out trailing default entry */
            while (first <= last) {
                probe = (first + last) / 2;
                if (sym == row[probe * 2]) {
                    return row[probe * 2 + 1];
                } else if (sym > row[probe * 2]) {
                    first = probe + 1;
                } else {
                    last = probe - 1;
                }
            }

            /* not found, use the default at the end */
            return row[row.length - 1];
        }

        /* shouldn't happened, but if we run off the end we return the 
         default (error == 0) */
        return 0;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Fetch a state from the reduce-goto table. The table is broken up into
     * rows, one per state (rows are indexed directly by state number). Within
     * each row, a list of index, value pairs are given (as sequential entries
     * in the table), and the list is terminated by a default entry (denoted
     * with a Symbol index of -1). To find the proper entry in a row we do a
     * linear search.
     *
     * @param state the state index of the entry being accessed.
     * @param sym the Symbol index of the entry being accessed.
     */
    private short get_reduce(int state, int sym) {
        short tag;
        final short[] row = reduce_tab[state];

        /* if we have a null row we go with the default */
        if (row == null) {
            return -1;
        }

        for (int probe = 0; probe < row.length; probe++) {
            /* is this entry labeled with our Symbol or the default? */
            tag = row[probe++];
            if (tag == sym || tag == -1) {
                /* return the next entry */
                return row[probe];
            }
        }
        /* if we run off the end we return the default (error == -1) */
        return -1;
    }
    protected boolean symbolNoRightLeft = false;

    private Symbol reduce_action(int action) throws Exception {
        Object result = do_action(action);
        //SymbolFactory symbolFactory = this.getSymbolFactory();
        Symbol lhs_sym;

        int lhs_sym_id = production_tab[action][0];
        int handle_size = production_tab[action][1];

        String symbolName = nonTerminalNames[lhs_sym_id];

        if (symbolNoRightLeft || handle_size == 0) {
            lhs_sym = symbolFactory.newSymbol(symbolName, lhs_sym_id, result);
        } else {
            Symbol right = stack.peek();
            Symbol left = handle_size <= 1 ? right : stack.peek(handle_size - 1);
            lhs_sym = symbolFactory.newSymbol(symbolName, lhs_sym_id, left, right, result);
        }

        /* look up information about the production */


        /* pop the handle off the stack */
        for (int i = 0; i < handle_size; i++) {
            stack.pop();
            tos--;
        }

        /* look up the state to go to from the one popped back to */
        int parse_state = get_reduce(stack.peek().parse_state, lhs_sym_id);

        /* shift to that state */
        lhs_sym.parse_state = parse_state;
        lhs_sym.used_by_parser = true;
        stack.push(lhs_sym);
        tos++;

        return lhs_sym;
    }
    protected Template template;
    protected TextStatmentFactory textStatmentFactory;
    protected PlaceHolderStatmentFactory placeHolderStatmentFactory;
    protected NativeSecurityManager nativeSecurityManager;
    protected Logger logger;
    protected boolean locateVarForce;
    protected Lexer lexer;

    public final int getLine() {
        return lexer != null ? lexer.getLine() : 0;
    }

    public final int getColumn() {
        return lexer != null ? lexer.getColumn() : 0;
    }

    /**
     * 
     * @param in java.io.Reader
     * @param template Template
     * @return
     * @throws ParserException
     */
    public TemplateAST parseTemplate(java.io.Reader in, Template template) throws ParserException {
        try {
            this.lexer = new Lexer(in);
            this.template = template;
            final Engine engine = template.engine;
            this.logger = engine.getLogger();
            TextStatmentFactory _textStatmentFactory;
            this.textStatmentFactory = _textStatmentFactory = engine.getTextStatmentFactory();
            this.nativeSecurityManager = engine.getNativeSecurityManager();
            this.locateVarForce = !engine.isLooseVar();
            this.placeHolderStatmentFactory = new PlaceHolderStatmentFactory(engine.getFilter());

            _textStatmentFactory.startTemplateParser(template);
            Symbol sym = this.parse();
            _textStatmentFactory.finishTemplateParser(template);
            return (TemplateAST) sym.value;
        } catch (Exception e) {
            if (e instanceof ParserException) {
                throw (ParserException) e;
            } else {
                throw new ParserException(e);
            }
        } finally {
            try {
                this.lexer.yyclose();
            } catch (Exception e) {
                //ignore
            }
        }
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * This method provides the main parsing routine. It returns only when
     * finishParsing() has been called (typically because the parser has
     * accepted, or a fatal error has been reported). See the header
     * documentation for the class regarding how shift/reduce parsers operate
     * and how the various tables are used.
     */
    private Symbol parse() throws Exception {
        /* the current action code */
        int act;

        /* the Symbol/stack element returned by a reduce */
        Symbol lhs_sym = null;

        /* set up direct reference to tables to drive the parser */

        /* initialize the action encapsulation object */
        init_actions();

        /* do user initialization */
        user_init();

        /* get the first token */
        cur_token = scan();

        /* push dummy Symbol with start state to get us underway */
        stack.clear();
        stack.push(symbolFactory.startSymbol("START", 0, start_state()));
        tos = 0;

        /* continue until we are told to stop */
        isParseDone = false;
        while (!isParseDone) {
            /* Check current token for freshness. */
            if (cur_token.used_by_parser) {
                throw new Error("Symbol recycling detected (fix your scanner).");
            }

            /* current state is always on the top of the stack */

            /* look up action out of the current state with the current input */
            act = get_action(stack.peek().parse_state, cur_token.sym);

            /* decode the action -- > 0 encodes shift */
            if (act > 0) {
                /* shift to the encoded state by pushing it on the stack */
                cur_token.parse_state = act - 1;
                cur_token.used_by_parser = true;
                stack.push(cur_token);
                tos++;

                /* advance to the next Symbol */
                cur_token = scan();
            } /* if its less than zero, then it encodes a reduce action */ else if (act < 0) {
                /* perform the action for the reduce */
                lhs_sym = reduce_action((-act) - 1);
            } /* finally if the entry is zero, we have an error */ else if (act == 0) {
                /* call user syntax error reporting routine */
                syntax_error(cur_token);

                /* try to error recover */
                if (!error_recovery()) {
                    /* if that fails give up with a fatal syntax error */
                    unrecovered_syntax_error(cur_token);

                    /* just in case that wasn't fatal enough, end parse */
                    doneParse();
                } else {
                    lhs_sym = stack.peek();
                }
            }
        }
        return lhs_sym;
    }


    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /* Error recovery code */
    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Attempt to recover from a syntax error. This returns false if recovery
     * fails, true if it succeeds. Recovery happens in 4 steps. First we pop the
     * parse stack down to a point at which we have a shift out of the top-most
     * state on the error Symbol. This represents the initial error recovery
     * configuration. If no such configuration is found, then we fail. Next a
     * small number of "lookahead" or "parse ahead" Symbols are read into a
     * buffer. The size of this buffer is determined by error_sync_size() and
     * determines how many Symbols beyond the error must be matched to consider
     * the recovery a success. Next, we begin to discard Symbols in attempt to
     * get past the point of error to a point where we can continue parsing.
     * After each Symbol, we attempt to "parse ahead" though the buffered
     * lookahead Symbols. The "parse ahead" process simulates that actual parse,
     * but does not modify the real parser's configuration, nor execute any
     * actions. If we can parse all the stored Symbols without error, then the
     * recovery is considered a success. Once a successful recovery point is
     * determined, we do an actual parse over the stored input -- modifying the
     * real parse configuration and executing all actions. Finally, we return
     * the the normal parser to continue with the overall parse.
     *
     */
    private boolean error_recovery()
            throws Exception {

        /* first pop the stack back into a state that can shift on error and 
         do that shift (if that fails, we fail) */
        if (!find_recovery_config()) {
            return false;
        }

        /* read ahead to create lookahead we can parse multiple times */
        read_lookahead();

        /* repeatedly try to parse forward until we make it the required dist */
        for (;;) {
            /* try to parse forward, if it makes it, bail out of loop */
            if (try_parse_ahead()) {
                break;
            }

            /* if we are now at EOF, we have failed */
            if (lookahead[0].sym == EOF_sym()) {
                return false;
            }

            /* otherwise, we consume another Symbol and try again */
            // BUG FIX by Bruce Hutton
            // Computer Science Department, University of Auckland,
            // Auckland, New Zealand.
            // It is the first token that is being consumed, not the one 
            // we were up to parsing
            restart_lookahead();
        }

        /* we have consumed to a point where we can parse forward */

        /* do the real parse (including actions) across the lookahead */
        parse_lookahead();

        /* we have success */
        return true;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Determine if we can shift under the special error Symbol out of the state
     * currently on the top of the (real) parse stack.
     */
    private boolean shift_under_error() {
        /* is there a shift under error Symbol */
        return get_action(stack.peek().parse_state, error_sym()) > 0;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Put the (real) parse stack into error recovery configuration by popping
     * the stack down to a state that can shift on the special error Symbol,
     * then doing the shift. If no suitable state exists on the stack we return
     * false
     */
    private boolean find_recovery_config() {
        Symbol error_token;
        int act;

        /* Remember the column-position of the top symbol on the stack */
        Symbol right = stack.peek();// TUM 20060327 removed .column	
        Symbol left = right;// TUM 20060327 removed .line	

        /* pop down until we can shift under error Symbol */
        while (!shift_under_error()) {
            /* pop the stack */
            left = (stack.pop()); // TUM 20060327 removed .line	
            tos--;

            /* if we have hit bottom, we fail */
            if (stack.empty()) {
                return false;
            }
        }

        /* state on top of the stack can shift under error, find the shift */
        act = get_action(stack.peek().parse_state, error_sym());

        /* build and shift a special error Symbol */
        error_token = symbolFactory.newSymbol("ERROR", error_sym(), left, right);
        error_token.parse_state = act - 1;
        error_token.used_by_parser = true;
        stack.push(error_token);
        tos++;

        return true;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Lookahead Symbols used for attempting error recovery "parse aheads".
     */
    private Symbol lookahead[];
    /**
     * Position in lookahead input buffer used for "parse ahead".
     */
    private int lookahead_pos;

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Read from input to establish our buffer of "parse ahead" lookahead
     * Symbols.
     */
    private void read_lookahead() throws Exception {
        /* create the lookahead array */
        lookahead = new Symbol[error_sync_size()];

        /* fill in the array */
        for (int i = 0; i < error_sync_size(); i++) {
            lookahead[i] = cur_token;
            cur_token = scan();
        }

        /* start at the beginning */
        lookahead_pos = 0;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Return the current lookahead in our error "parse ahead" buffer.
     */
    private Symbol cur_err_token() {
        return lookahead[lookahead_pos];
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Advance to next "parse ahead" input Symbol. Return true if we have input
     * to advance to, false otherwise.
     */
    private boolean advance_lookahead() {
        /* advance the input location */
        lookahead_pos++;

        /* return true if we didn't go off the end */
        return lookahead_pos < error_sync_size();
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Reset the parse ahead input to one Symbol past where we started error
     * recovery (this consumes one new Symbol from the real input).
     */
    private void restart_lookahead() throws Exception {
        /* move all the existing input over */
        for (int i = 1; i < error_sync_size(); i++) {
            lookahead[i - 1] = lookahead[i];
        }

        /* read a new Symbol into the last spot */
        // BUG Fix by Bruce Hutton
        // Computer Science Department, University of Auckland,
        // Auckland, New Zealand. [applied 5-sep-1999 by csa]
        // The following two lines were out of order!!
        lookahead[error_sync_size() - 1] = cur_token;
        cur_token = scan();

        /* reset our internal position marker */
        lookahead_pos = 0;
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Do a simulated parse forward (a "parse ahead") from the current stack
     * configuration using stored lookahead input and a virtual parse stack.
     * Return true if we make it all the way through the stored lookahead input
     * without error. This basically simulates the action of parse() using only
     * our saved "parse ahead" input, and not executing any actions.
     *
     */
    private boolean try_parse_ahead()
            throws Exception {
        int act;
        short lhs, rhs_size;

        /* create a virtual stack from the real parse stack */
        virtual_parse_stack vstack = new virtual_parse_stack(stack);

        /* parse until we fail or get past the lookahead input */
        for (;;) {
            /* look up the action from the current state (on top of stack) */
            act = get_action(vstack.top(), cur_err_token().sym);

            /* if its an error, we fail */
            if (act == 0) {
                return false;
            }

            /* > 0 encodes a shift */
            if (act > 0) {
                /* push the new state on the stack */
                vstack.push(act - 1);

                /* advance simulated input, if we run off the end, we are done */
                if (!advance_lookahead()) {
                    return true;
                }
            } /* < 0 encodes a reduce */ else {
                /* if this is a reduce with the start production we are done */
                if ((-act) - 1 == start_production()) {
                    return true;
                }

                /* get the lhs Symbol and the rhs size */
                lhs = production_tab[(-act) - 1][0];
                rhs_size = production_tab[(-act) - 1][1];

                /* pop handle off the stack */
                for (int i = 0; i < rhs_size; i++) {
                    vstack.pop();
                }

                /* look up goto and push it onto the stack */
                vstack.push(get_reduce(vstack.top(), lhs));
            }
        }
    }

    /*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .*/
    /**
     * Parse forward using stored lookahead Symbols. In this case we have
     * already verified that parsing will make it through the stored lookahead
     * Symbols and we are now getting back to the point at which we can hand
     * control back to the normal parser. Consequently, this version of the
     * parser performs all actions and modifies the real parse configuration.
     * This returns once we have consumed all the stored input or we accept.
     *
     */
    private void parse_lookahead()
            throws Exception {
        /* the current action code */
        int act;

        /* the Symbol/stack element returned by a reduce */
        Symbol lhs_sym = null;


        /* restart the saved input at the beginning */
        lookahead_pos = 0;

        Symbol cur_err_token;

        /* continue until we accept or have read all lookahead input */
        while (!isParseDone) {
            /* current state is always on the top of the stack */

            cur_err_token = cur_err_token();
            /* look up action out of the current state with the current input */
            act = get_action(stack.peek().parse_state, cur_err_token.sym);

            /* decode the action -- > 0 encodes shift */
            if (act > 0) {
                /* shift to the encoded state by pushing it on the stack */
                cur_err_token.parse_state = act - 1;
                cur_err_token.used_by_parser = true;

                stack.push(cur_err_token);
                tos++;

                /* advance to the next Symbol, if there is none, we are done */
                if (!advance_lookahead()) {


                    /* scan next Symbol so we can continue parse */
                    // BUGFIX by Chris Harris <ckharris@ucsd.edu>:
                    //   correct a one-off error by commenting out
                    //   this next line.
		  /*cur_token = scan();*/

                    /* go back to normal parser */
                    return;
                }


            } /* if its less than zero, then it encodes a reduce action */ else if (act < 0) {
                /* perform the action for the reduce */


                lhs_sym = reduce_action((-act) - 1);


            } /* finally if the entry is zero, we have an error 
             (shouldn't happen here, but...)*/ else if (act == 0) {
                report_fatal_error("Syntax error", lhs_sym);
                return;
            }
        }


    }

    /*-----------------------------------------------------------*/
    /**
     * Utility function: unpacks parse tables from strings
     */
    protected static short[][] unpackFromStrings(String[] sa) {
        // Concatanate initialization strings.
        StringBuilder sb = new StringBuilder(sa[0]);
        for (int i = 1; i < sa.length; i++) {
            sb.append(sa[i]);
        }
        int n = 0; // location in initialization string
        int size1 = (((int) sb.charAt(n)) << 16) | ((int) sb.charAt(n + 1));
        n += 2;
        short[][] result = new short[size1][];
        for (int i = 0; i < size1; i++) {
            int size2 = (((int) sb.charAt(n)) << 16) | ((int) sb.charAt(n + 1));
            n += 2;
            result[i] = new short[size2];
            for (int j = 0; j < size2; j++) {
                result[i][j] = (short) (sb.charAt(n++) - 2);
            }
        }
        return result;
    }
}
